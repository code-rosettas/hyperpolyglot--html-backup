
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<link rel="icon" type="image/gif" href="/favicon.gif"/>
<link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png" />
<link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png" />
<title>Lorem Ipsum</title>


<script type="text/javascript"
  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css" id="internal-style">
@import url(hyperpolyglot.css);
</style>
<meta http-equiv="content-type" content="text/html;charset=UTF-8"/>
<meta http-equiv="content-language" content="en"/>
</head>

<body>
<div id="container-wrap-wrap">
  <div id="container-wrap">
    <div id="container">
      <div id="header">
        <h1><a href="/"><span>Hyperpolyglot</span></a></h1>
      </div>
      <div id="content-wrap">
        <div id="main-content">
          <div id="page-title">Lorem Ipsum</div>
          <div id="page-content">

<p><a name="top"></a><em>a side-by-side reference sheet</em></p>
<p><strong><a href="/numerical-analysis">sheet one:</a></strong> <a href="/numerical-analysis#grammar-invocation">grammar and invocation</a> | <a href="/numerical-analysis#var-expr">variables and expressions</a> | <a href="/numerical-analysis#arithmetic-logic">arithmetic and logic</a> | <a href="/numerical-analysis#strings">strings</a> | <a href="/numerical-analysis#regexes">regexes</a> | <a href="/numerical-analysis#dates-time">dates and time</a> | <a href="/numerical-analysis#tuples">tuples</a> | <a href="/numerical-analysis#arrays">arrays</a> | <a href="/numerical-analysis#arithmetic-sequences">arithmetic sequences</a> | <a href="/numerical-analysis#two-d-arrays">2d arrays</a> | <a href="/numerical-analysis#three-d-arrays">3d arrays</a> | <a href="/numerical-analysis#dictionaries">dictionaries</a> | <a href="/numerical-analysis#functions">functions</a> | <a href="/numerical-analysis#execution-control">execution control</a> | <a href="/numerical-analysis#file-handle">file handles</a> | <a href="/numerical-analysis#directories">directories</a> | <a href="/numerical-analysis#processes-environment">processes and environment</a> | <a href="/numerical-analysis#libraries-namespaces">libraries and namespaces</a> | <a href="/numerical-analysis#reflection">reflection</a> | <a href="/numerical-analysis#debugging">debugging</a></p>
<p><strong>sheet two:</strong> <a href="#tables">tables</a> | <a href="#import-export">import and export</a> | <a href="#relational-algebra">relational algebra</a> | <a href="#aggregation">aggregation</a></p>
<p><a href="#vectors">vectors</a> | <a href="#matrices">matrices</a> | <a href="#sparse-matrices">sparse matrices</a> | <a href="#optimization">optimization</a> | <a href="#polynomials">polynomials</a> | <a href="#descriptive-statistics">descriptive statistics</a> | <a href="#distributions">distributions</a> | <a href="#linear-regression">linear regression</a> | <a href="#statistical-tests">statistical tests</a> | <a href="#time-series">time series</a> | <a href="#fast-fourier-transform">fast fourier transform</a> | <a href="#clustering">clustering</a> | <a href="#images">images</a> | <a href="#sound">sound</a></p>
<p><a href="#bar-charts">bar charts</a> | <a href="#scatter-plots">scatter plots</a> | <a href="#line-charts">line charts</a> | <a href="#surface-charts">surface charts</a> | <a href="#chart-options">chart options</a></p>
<table class="wiki-content-table">
<tr>
<th colspan="5"><a name="tables"></a><a href="#tables-note">tables</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="construct-from-column-arrays"></a><a href="#construct-from-column-arrays-note">construct from column arrays</a></td>
<td>sx = {&#x27;F&#x27; &#x27;F&#x27; &#x27;F&#x27; &#x27;M&#x27; &#x27;M&#x27; &#x27;M&#x27;}<br />
ht = [69 64 67 68 72 71]<br />
wt = [148 132 142 149 167 165]<br />
cols = {&#x27;sx&#x27;, &#x27;ht&#x27;, &#x27;wt&#x27;}<br />
people = table(sx&#x27;, ht&#x27;, wt&#x27;, &#x27;VariableNames&#x27;, cols)</td>
<td><span style="color: gray"># gender, height, weight of some people<br />
# in inches and lbs:</span><br />
sx = c(&quot;F&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;M&quot;)<br />
ht = c(69, 64, 67, 68, 72, 71)<br />
wt = c(148, 132, 142, 149, 167, 165)<br />
people = data.frame(sx, ht, wt)</td>
<td>sx = ['F', &#x27;F&#x27;, &#x27;F&#x27;, &#x27;F&#x27;, &#x27;M&#x27;, &#x27;M&#x27;]<br />
ht = [69, 64, 67, 66, 72, 70]<br />
wt = [150, 132, 142, 139, 167, 165]<br />
people = pd.DataFrame({&#x27;sx&#x27;: sx, &#x27;ht&#x27;: ht, &#x27;wt&#x27;: wt})</td>
<td> </td>
</tr>
<tr>
<td><a name="construct-from-row-dictionaries"></a><a href="#construct-from-row-dictionaries-note">construct from row dictionaries</a></td>
<td> </td>
<td> </td>
<td>rows = [<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>{&#x27;sx&#x27;: &#x27;F&#x27;, &#x27;ht&#x27;: 69, &#x27;wt&#x27;: 150},<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>{&#x27;sx&#x27;: &#x27;F&#x27;, &#x27;ht&#x27;: 64, &#x27;wt&#x27;: 132},<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>{&#x27;sx&#x27;: &#x27;F&#x27;, &#x27;ht&#x27;: 67, &#x27;wt&#x27;: 142},<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>{&#x27;sx&#x27;: &#x27;F&#x27;, &#x27;ht&#x27;: 66, &#x27;wt&#x27;: 139},<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>{&#x27;sx&#x27;: &#x27;M&#x27;, &#x27;ht&#x27;: 72, &#x27;wt&#x27;: 167},<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>{&#x27;sx&#x27;: &#x27;M&#x27;, &#x27;ht&#x27;: 70, &#x27;wt&#x27;: 165}]<br />
people = pd.DataFrame(rows)</td>
<td> </td>
</tr>
<tr>
<td><a name="table-size"></a><a href="#table-size-note">size</a></td>
<td>height(people)<br />
width(people)</td>
<td>nrow(people)<br />
ncol(people)<br />
<br />
<span style="color: gray"># number of rows and cols in 2-element vector:</span><br />
dim(people)</td>
<td>len(people)<br />
len(people.columns)</td>
<td> </td>
</tr>
<tr>
<td><a name="column-names-as-array"></a><a href="#column-names-as-array-note">column names as array</a></td>
<td>people.Properties.VariableNames</td>
<td>names(people)<br />
colnames(people)</td>
<td><span style="color: gray"><em>returns</em> Index <em>object:</em></span><br />
people.columns</td>
<td> </td>
</tr>
<tr>
<td><a name="access-column-as-array"></a><a href="#access-column-as-array-note">access column as array</a></td>
<td>people.ht<br />
people.(2)</td>
<td><span style="color: gray"># vectors:</span><br />
people$ht<br />
people[,2]<br />
people[['ht']]<br />
people[[2]]<br />
<span style="color: gray"># 1 column data frame:</span><br />
people[2]</td>
<td>people[&#x27;ht&#x27;]<br />
<br />
<span style="color: gray"># if name does not conflict with any DataFrame attributes:</span><br />
people.ht</td>
<td> </td>
</tr>
<tr>
<td><a name="access-row-as-tuple"></a><a href="#access-row-as-tuple-note">access row as tuple</a></td>
<td>people(1,:)</td>
<td><span style="color: gray"># 1 row data frame:</span><br />
people[1, ]<br />
<span style="color: gray"># list:</span><br />
as.list(people[1, ])</td>
<td>people.ix[0]</td>
<td> </td>
</tr>
<tr>
<td><a name="access-datum"></a><a href="#access-datum-note">access datum</a></td>
<td><span style="color: gray">% height of 1st person:</span><br />
people(1,2)</td>
<td><span style="color: gray"># height of 1st person:</span><br />
people[1,2]</td>
<td>people.get_value(0, &#x27;ht&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="order-rows-by-column"></a><a href="#order-rows-by-column-note">order rows by column</a></td>
<td>sortrows(people, &#x27;ht&#x27;)</td>
<td>people[order(people$ht), ]</td>
<td>people.sort([&#x27;ht&#x27;])</td>
<td> </td>
</tr>
<tr>
<td><a name="order-rows-by-multiple-columns"></a><a href="#order-rows-by-multiple-columns-note">order rows by multiple columns</a></td>
<td>sortrows(people, {&#x27;sx&#x27;, &#x27;ht&#x27;})</td>
<td>people[order(people$sx, people$ht), ]</td>
<td>people.sort([&#x27;sx&#x27;, &#x27;ht&#x27;])</td>
<td> </td>
</tr>
<tr>
<td><a name="order-rows-descending-order"></a><a href="#order-rows-descending-order-note">order rows in descending order</a></td>
<td>sortrows(people, &#x27;ht&#x27;, &#x27;descend&#x27;)</td>
<td>people[order(-people$ht), ]</td>
<td>people.sort(&#x27;ht&#x27;, ascending=[False])</td>
<td> </td>
</tr>
<tr>
<td><a name="limit-rows"></a><a href="#limit-rows-note">limit rows</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>people(1:3, :)</td>
<td>people[seq(1, 3), ]</td>
<td>people[0:3]</td>
<td> </td>
</tr>
<tr>
<td><a name="offset-rows"></a><a href="#offset-rows-note">offset rows</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>people(4:6, :)</td>
<td>people[seq(4, 6), ]</td>
<td>people[3:]</td>
<td> </td>
</tr>
<tr>
<td><a name="reshape-table"></a><a href="#reshape-table-note">reshape</a></td>
<td> </td>
<td>people$couple = c(1, 2, 3, 1, 2, 3)<br />
reshape(people, idvar=&quot;couple&quot;, direction=&quot;wide&quot;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>timevar=&quot;sx&quot;, v.names=c(&quot;ht&quot;, &quot;wt&quot;))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="rm-rows-with-null-fields"></a><a href="#rm-rows-with-null-fields-note">remove rows with null fields</a></td>
<td> </td>
<td>sx = c(&#x27;F&#x27;, &#x27;F&#x27;, &#x27;M&#x27;, &#x27;M&#x27;)<br />
wt = c(120, NA, 150, 170)<br />
<br />
df = data.frame(sx, wt)<br />
df2 = na.omit(df)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="attach-columns"></a><a href="#attach-columns-note">attach columns</a></td>
<td> </td>
<td><span style="color: gray"># put columns ht, wt, and sx<br />
# in variable name search path:</span><br />
attach(people)<br />
sum(ht)<br />
<br />
<span style="color: gray"># alternative which doesn&#x27;t put columns in<br />
# search path:</span><br />
with(people, sum(ht))</td>
<td><span style="color: gray"><em>none</em></span></td>
<td> </td>
</tr>
<tr>
<td><a name="detach-columns"></a><a href="#detach-columns-note">detach columns</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td> </td>
<td>detach(people)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td> </td>
</tr>
<tr>
<td><a name="spreadsheet-editor"></a><a href="#spreadsheet-editor-note">spreadsheet editor</a></td>
<td> </td>
<td><span style="color: gray"><em>can edit data, in which case return value of</em> edit <em>must be saved</em></span><br />
people = edit(people)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="import-export"></a><a href="#import-export-note">import and export</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="import-tab-delimited"></a><a href="#import-tab-delimited-note">import tab delimited</a></td>
<td><span style="color: gray"># first row defines variable names:</span><br />
readtable(&#x27;/tmp/password.txt&#x27;, &#x27;Delimiter&#x27;, &#x27;\t&#x27;)<br />
<br />
<span style="color: gray"># file suffix must be .txt, .dat, or .csv</span></td>
<td><span style="color: gray"># first row defines variable names:</span><br />
df = read.delim(&#x27;/path/to.tab&#x27;, stringsAsFactors=F, quote=NULL)</td>
<td><span style="color: gray"># first row defines column names:</span><br />
df = pd.read_table(&#x27;/path/to.tab&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="import-csv"></a><a href="#import-csv-note">import csv</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td><span style="color: gray">% first row defines variable names:</span><br />
df = readtable(&#x27;/path/to.csv&#x27;)</td>
<td><span style="color: gray"># first row defines variable names:</span><br />
df = read.csv(&#x27;/path/to.csv&#x27;, stringsAsFactors=F)</td>
<td><span style="color: gray"># first row defines column names:</span><br />
df = pd.read_csv(&#x27;/path/to.csv&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="set-column-separator"></a><a href="#set-column-separator-note">set column separator</a></td>
<td>df = readtable(&#x27;/etc/passwd&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;Delimiter&#x27;, &#x27;:&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;ReadVariableNames&#x27;, 0,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;HeaderLines&#x27;, 10)</td>
<td>df = read.delim(&#x27;/etc/passwd&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>sep=&#x27;:&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>header=FALSE,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>comment.char=&#x27;#&#x27;)</td>
<td><span style="color: gray"># $ grep -v &#x27;^#&#x27; /etc/passwd &gt; /tmp/passwd</span><br />
<br />
df = pd.read_table(&#x27;/tmp/passwd&#x27;, sep=&#x27;:&#x27;, header=None)</td>
<td> </td>
</tr>
<tr>
<td><a name="set-column-separator-whitesp"></a><a href="#set-column-separator-whitesp-note">set column separator to whitespace</a></td>
<td> </td>
<td>df = read.delim(&#x27;/path/to.txt&#x27;, sep=&#x27;&#x27;)</td>
<td>df = read_table(&#x27;/path/to.txt&#x27;, sep=&#x27;\s+&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="set-quote-char"></a><a href="#set-quote-char-note">set quote character</a></td>
<td> </td>
<td><span style="color: gray"># default quote character for both read.csv and read.delim<br />
# is double quotes. The quote character is escaped by doubling it.</span><br />
<br />
<span style="color: gray"># use single quote as quote character:</span><br />
df = read.csv(&#x27;/path/to/single-quote.csv&#x27;, quote=&quot;&#x27;&quot;)<br />
<br />
<span style="color: gray"># no quote character:</span><br />
df = read.csv(&#x27;/path/to/no-quote.csv&#x27;, quote=&quot;&quot;)</td>
<td><span style="color: gray"><em>Both</em> read_table <em>and</em> read_csv <em>use double quotes as the quote character and there is no way to change it. A double quote can be escaped by doubling it.</em></span></td>
<td> </td>
</tr>
<tr>
<td><a name="import-file-without-header"></a><a href="#import-file-without-header-note">import file w/o header</a></td>
<td> </td>
<td><span style="color: gray"># column names are V1, V2, ...</span><br />
read.delim(&#x27;/etc/passwd&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>sep=&#x27;:&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>header=FALSE,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>comment.char=&#x27;#&#x27;)</td>
<td><span style="color: gray"># $ grep -v &#x27;^#&#x27; /etc/passwd &gt; /tmp/passwd</span><br />
<span style="color: gray"># </span><br />
<span style="color: gray"># column names are X0, X1, ...</span><br />
df = pd.read_table(&#x27;/tmp/passwd&#x27;, sep=&#x27;:&#x27;, header=None)</td>
<td> </td>
</tr>
<tr>
<td><a name="set-column-names"></a><a href="#set-column-names-note">set column names</a></td>
<td>df = readtable(&#x27;/path/to/no-header.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;ReadVariableNames&#x27;, 0)<br />
<br />
df.Properties.VariableNames = {&#x27;ht&#x27;, &#x27;wt&#x27;, &#x27;age&#x27;}</td>
<td>df = read.csv(&#x27;/path/to/no-header.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>header=FALSE,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>col.names=c(&#x27;ht&#x27;, &#x27;wt&#x27;, &#x27;age&#x27;))</td>
<td>df = pd.read_csv(&#x27;/path/to/no-header.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>names=[&#x27;ht&#x27;, &#x27;wt&#x27;, &#x27;age&#x27;])</td>
<td> </td>
</tr>
<tr>
<td><a name="set-column-types"></a><a href="#set-column-types-note">set column types</a></td>
<td> </td>
<td><span style="color: gray"># possible values: NA, &#x27;logical&#x27;, &#x27;integer&#x27;, &#x27;numeric&#x27;,<br />
# &#x27;complex&#x27;, &#x27;character&#x27;, &#x27;raw&#x27;, &#x27;factor&#x27;, &#x27;Date&#x27;,<br />
# &#x27;POSIXct&#x27;<br />
#<br />
# If type is set to NA, actual type will be inferred to be<br />
# &#x27;logical&#x27;, &#x27;integer&#x27;, &#x27;numeric&#x27;, &#x27;complex&#x27;, or &#x27;factor&#x27;<br />
# </span><br />
df = read.csv(&#x27;/path/to/data.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>colClasses=c(&#x27;integer&#x27;, &#x27;numeric&#x27;, &#x27;character&#x27;))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="recognize-null-values"></a><a href="#recognize-null-values-note">recognize null values</a></td>
<td> </td>
<td>df = read.csv(&#x27;/path/to/data.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>colClasses=c(&#x27;integer&#x27;, &#x27;logical&#x27;, &#x27;character&#x27;),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>na.strings=c(&#x27;nil&#x27;))</td>
<td>df = read_csv(&#x27;/path/to/data.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>na_values=[&#x27;nil&#x27;])</td>
<td> </td>
</tr>
<tr>
<td><a name="change-decimal-mark"></a><a href="#change-decimal-mark-note">change decimal mark</a></td>
<td> </td>
<td>df = read.csv(&#x27;/path/to.csv&#x27;, dec=&#x27;,&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="recognize-thousands-separator"></a><a href="#recognize-thousands-separator-note">recognize thousands separator</a></td>
<td> </td>
<td><span style="color: gray"><em>none</em></span></td>
<td>df = read_csv(&#x27;/path/to.csv&#x27;, thousands=&#x27;.&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="unequal-row-length-behavior"></a><a href="#unequal-row-length-behavior-note">unequal row length behavior</a></td>
<td> </td>
<td><span style="color: gray"><em>Missing fields will be set to NA unless</em> fill <em>is set to</em> FALSE. <em>If the column is of type character then the fill value is an empty string &#x27;&#x27;.<br />
<br />
If there are extra fields they will be parsed as an extra row unless</em> flush <em>is set to</em> FALSE</span></td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="skip-comment-lines"></a><a href="#skip-comment-lines-note">skip comment lines</a></td>
<td> </td>
<td>df = read.delim(&#x27;/etc/passwd&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>sep=&#x27;:&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>header=FALSE,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>comment.char=&#x27;#&#x27;)</td>
<td><span style="color: gray"><em>none</em></span></td>
<td> </td>
</tr>
<tr>
<td><a name="skip-rows"></a><a href="#skip-rows-note">skip rows</a></td>
<td>def = readtable(&#x27;/path/to/data.csv&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;HeaderLines&#x27;, 4)</td>
<td>df = read.csv(&#x27;/path/to/data.csv&#x27;, skip=4)</td>
<td>df = read_csv(&#x27;/path/to/data.csv&#x27;, skiprows=4)<br />
<br />
<span style="color: gray"># rows to skip can be specified individually:</span><br />
df = read_csv(&#x27;/path/to/data.csv&#x27;, skiprows=range(0, 4))</td>
<td> </td>
</tr>
<tr>
<td><a name="max-rows-to-read"></a><a href="#max-rows-to-read-note">max rows to read</a></td>
<td> </td>
<td>df = read.csv(&#x27;/path/to/data.csv&#x27;, nrows=4)</td>
<td>df = read_csv(&#x27;/path/to/data.csv&#x27;, nrows=4)</td>
<td> </td>
</tr>
<tr>
<td><a name="index-column"></a><a href="#index-column-note">index column</a></td>
<td> </td>
<td><span style="color: gray"><em>none</em></span></td>
<td>df = pd.read_csv(&#x27;/path/to.csv&#x27;, index_col=&#x27;key_col&#x27;)<br />
<br />
<span style="color: gray"># hierarchical index:</span><br />
df = pd.read_csv(&#x27;/path/to.csv&#x27;, index_col=[&#x27;col1&#x27;, &#x27;col2&#x27;])</td>
<td> </td>
</tr>
<tr>
<td><a name="export-tab-delimited"></a><a href="#export-tab-delimited-note">export tab delimited</a></td>
<td> </td>
<td>write.table(df, &#x27;/tmp/data.tab&#x27;, sep=&#x27;\t&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="export-csv"></a><a href="#export-csv-note">export csv</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td> </td>
<td><span style="color: gray"># first column contains row names unless row.names<br />
# set to FALSE</span><br />
write.csv(df, &#x27;/path/to.csv&#x27;, row.names=F)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="relational-algebra"></a><a href="#relational-algebra-note">relational algebra</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td>project columns by name</td>
<td>people(:, {&#x27;sx&#x27;, &#x27;ht&#x27;})</td>
<td>people[c(&#x27;sx&#x27;, &#x27;ht&#x27;)]</td>
<td>people[['sx', 'ht']]</td>
<td> </td>
</tr>
<tr>
<td>project columns by position</td>
<td>people(:, [1 2])</td>
<td>people[c(1, 2)]</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>project expression</td>
<td> </td>
<td><span style="color: gray"># convert to cm and kg:</span><br />
transform(people, ht=2.54*ht, wt=wt/2.2)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>project all columns</td>
<td>people(people.ht &gt; 66, :)</td>
<td>people[people$ht &gt; 66, ]</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>rename columns</td>
<td> </td>
<td>colnames(people) = c(&#x27;gender&#x27;, &#x27;height&#x27;, &#x27;weight&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="access-sub-data-set"></a><a href="#access-sub-data-set-note">access sub data frame</a></td>
<td> </td>
<td><span style="color: gray"># data frame of first 3 rows with<br />
# ht and wt columns reversed:</span><br />
people[1:3, c(1, 3, 2)]</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="data-set-filter"></a><a href="#data-set-filter-note">select rows</a></td>
<td>people(people.ht &gt; 66, :)</td>
<td>subset(people, ht &gt; 66)<br />
people[people$ht &gt; 66, ]</td>
<td>people[people[&#x27;ht&#x27;] &gt; 66]</td>
<td> </td>
</tr>
<tr>
<td>select distinct rows</td>
<td>unique(people(:,{&#x27;sx&#x27;}))</td>
<td>unique(people[c(&#x27;sx&#x27;)])</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>split rows</td>
<td> </td>
<td><span style="color: gray"># class(x) is list:</span><br />
x = split(people, people$sx == &#x27;F&#x27;)<br />
<br />
<span style="color: gray"># data.frame only containing females:</span><br />
x$T</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>inner join</td>
<td> </td>
<td>pw = read.delim(&#x27;/etc/passwd&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>sep=&#x27;:&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>header=F,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>comment.char=&#x27;#&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>col.names=c(&#x27;name&#x27;, &#x27;passwd&#x27;, &#x27;uid&#x27;, &#x27;gid&#x27;, &#x27;gecos&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;home&#x27;, &#x27;shell&#x27;))<br />
<br />
grp = read.delim(&#x27;/etc/group&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>sep=&#x27;:&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>header=F,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>comment.char=&#x27;#&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>col.names=c(&#x27;name&#x27;, &#x27;passwd&#x27;, &#x27;gid&#x27;, &#x27;members&#x27;))<br />
<br />
merge(pw, grp, by.x=&#x27;gid&#x27;, by.y=&#x27;gid&#x27;)</td>
<td><span style="color: gray"># $ grep -v &#x27;^#&#x27; /etc/passwd &gt; /tmp/passwd<br />
# $ grep -v &#x27;^#&#x27; /etc/group &gt; /tmp/group</span><br />
<br />
pw = pd.read_table(&#x27;/tmp/passwd&#x27;, sep=&#x27;:&#x27;, header=None, names=[&#x27;name&#x27;, &#x27;passwd&#x27;, &#x27;uid&#x27;, &#x27;gid&#x27;, &#x27;gecos&#x27;, &#x27;home&#x27;, &#x27;shell&#x27;])<br />
<br />
grp = pd.read_table(&#x27;/tmp/group&#x27;, sep=&#x27;:&#x27;, header=None, names=[&#x27;name&#x27;, &#x27;passwd&#x27;, &#x27;gid&#x27;, &#x27;members&#x27;])<br />
<br />
pd.merge(pw, grp, left_on=&#x27;gid&#x27;, right_on=&#x27;gid&#x27;)</td>
<td> </td>
</tr>
<tr>
<td>nulls as join values</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>left join</td>
<td> </td>
<td>merge(pw, grp, by.x=&#x27;gid&#x27;, by.y=&#x27;gid&#x27;, all.x=T)</td>
<td>pd.merge(pw, grp, left_on=&#x27;gid&#x27;, right_on=&#x27;gid&#x27;, how=&#x27;left&#x27;)</td>
<td> </td>
</tr>
<tr>
<td>full join</td>
<td> </td>
<td>merge(pw, grp, by.x=&#x27;gid&#x27;, by.y=&#x27;gid&#x27;, all=T)</td>
<td>pd.merge(pw, grp, left_on=&#x27;gid&#x27;, right_on=&#x27;gid&#x27;, how=&#x27;outer&#x27;)</td>
<td> </td>
</tr>
<tr>
<td>antijoin</td>
<td> </td>
<td>pw[!(pw$gid %in% grp$gid), ]</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>cross join</td>
<td> </td>
<td>merge(pw, grp, by=c())</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="aggregation"></a><a href="#aggregation-note">aggregation</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td>group by column</td>
<td> </td>
<td> </td>
<td>grouped = people.groupby(&#x27;sx&#x27;)<br />
grouped.aggregate(np.max)[&#x27;ht&#x27;]</td>
<td> </td>
</tr>
<tr>
<td>multiple aggregated values</td>
<td> </td>
<td> </td>
<td>grouped = people.groupby(&#x27;sx&#x27;)<br />
grouped.aggregate(np.max)[['ht', 'wt']]</td>
<td> </td>
</tr>
<tr>
<td>group by multiple columns</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>aggregation functions</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>nulls and aggregation functions</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="vectors"></a><a href="#vectors-note">vectors</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a href="#vector-literal">vector literal</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td><span style="color: gray"><em>same as array</em></span></td>
<td><span style="color: gray"><em>same as array</em></span></td>
<td><span style="color: gray"><em>same as array</em></span></td>
<td><span style="color: gray"><em>same as array</em></span></td>
</tr>
<tr>
<td><a href="#vector-element-wise">element-wise arithmetic operators</a></td>
<td>+ - .* ./</td>
<td>+ - * /</td>
<td>+ - * /</td>
<td>+ - .* ./</td>
</tr>
<tr>
<td><a href="#vector-length-mismatch">result of vector length mismatch</a></td>
<td><span style="color: gray"><em>raises error</em></span></td>
<td><span style="color: gray"><em>values in shorter vector are recycled; warning if one vector is not a multiple length of the other</em></span></td>
<td><span style="color: gray"><em>raises</em> ValueError</span></td>
<td><span style="color: gray">DimensionMismatch</span></td>
</tr>
<tr>
<td><a href="#vector-scalar">scalar multiplication</a></td>
<td>3 * [1, 2, 3]<br />
[1, 2, 3] * 3</td>
<td>3 * c(1, 2, 3)<br />
c(1, 2, 3) * 3</td>
<td>3 * np.array([1, 2, 3])<br />
np.array([1, 2, 3]) * 3</td>
<td>3 * [1, 2, 3]<br />
[1, 2, 3] * 3</td>
</tr>
<tr>
<td><a href="#vector-dot">dot product</a></td>
<td>dot([1, 1, 1], [2, 2, 2])</td>
<td>c(1, 1, 1) %*% c(2, 2, 2)</td>
<td>v1 = np.array([1, 1, 1])<br />
v2 = np.array([2, 2, 2])<br />
np.dot(v1, v2)</td>
<td>dot([1, 1, 1], [2, 2, 2])</td>
</tr>
<tr>
<td><a href="#vector-cross">cross product</a></td>
<td>cross([1, 0, 0], [0, 1, 0])</td>
<td> </td>
<td>v1 = np.array([1, 0, 0])<br />
v2 = np.array([0, 1, 0])<br />
np.cross(v1, v2)</td>
<td>cross([1, 0, 0], [0, 1, 0])</td>
</tr>
<tr>
<td><a href="#vector-norms">norms</a></td>
<td>norm([1, 2, 3], 1)<br />
norm([1, 2, 3], 2)<br />
norm([1, 2, 3], Inf)</td>
<td>vnorm = function(x, t) {<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>norm(matrix(x, ncol=1), t)<br />
}<br />
<br />
vnorm(c(1, 2, 3), &quot;1&quot;)<br />
vnorm(c(1, 2, 3), &quot;E&quot;)<br />
vnorm(c(1, 2, 3), &quot;I&quot;)</td>
<td>v = np.array([1, 2, 3])<br />
np.linalg.norm(v, 1)<br />
np.linalg.norm(v, 2)<br />
np.linalg.norm(v, np.inf)</td>
<td>v = [1, 2, 3]<br />
<br />
norm(v, 1)<br />
norm(v, 2)<br />
norm(v, Inf)</td>
</tr>
<tr>
<th colspan="5"><a name="matrices"></a><a href="#matrices-note">matrices</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="matrix-literal-constructor"></a><a href="#matrix-literal-constructor-note">literal or constructor</a></td>
<td><span style="color: gray">% row-major order:</span><br />
A = [1, 2; 3, 4]<br />
B = [4 3<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>2 1]</td>
<td><span style="color: gray"># column-major order:</span><br />
A = matrix(c(1, 3, 2, 4), 2, 2)<br />
B = matrix(c(4, 2, 3, 1), nrow=2)<br />
<br />
<span style="color: gray"># row-major order:</span><br />
A = matrix(c(1, 2, 3, 4), nrow=2, byrow=T)</td>
<td><span style="color: gray"># row-major order:</span><br />
A = np.matrix([[1, 2], [3, 4]])<br />
B = np.matrix([[4, 3], [2, 1]])</td>
<td>A = [1 2; 3 4]<br />
B = [4 3; 2 1]</td>
</tr>
<tr>
<td><a name="constant-matrices"></a><a href="#constant-matrices-note">constant matrices</a><br />
<span style="color: gray"><em>all zeros, all ones</em></span></td>
<td>zeros(3, 3) <span style="color: gray"><em>or</em></span> zeros(3)<br />
ones(3, 3) <span style="color: gray"><em>or</em></span> ones(3)</td>
<td>matrix(0, 3, 3)<br />
matrix(1, 3, 3)</td>
<td>np.matrix(np.ones([3, 3]))<br />
np.matrix(np.zeros([3, 3]))</td>
<td>zeros(Float64, (3, 3))<br />
ones(Float64, (3, 3))</td>
</tr>
<tr>
<td><a name="diagonal-matrices"></a><a href="#diagonal-matrices-note">diagonal matrices</a><br />
<span style="color: gray"><em>and identity</em></span></td>
<td>diag([1, 2, 3])<br />
<span style="color: gray">% 3x3 identity:</span><br />
eye(3)</td>
<td>diag(c(1, 2, 3)<br />
<span style="color: gray"># 3x3 identity:</span><br />
diag(3)</td>
<td>np.diag([1, 2, 3])<br />
np.identity(3)</td>
<td>diagm([1, 2, 3])<br />
eye(3)</td>
</tr>
<tr>
<td><a name="matrix-formula"></a><a href="#matrix-formula-note">matrix by formula</a></td>
<td>i = ones(10, 1) * (1:10)<br />
j = (1:10)&#x27; * ones(1, 10)<br />
<span style="color: gray">% use component-wise ops only:</span><br />
1 ./ (i + j - 1)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="matrix-dim"></a><a href="#matrix-dim-note">dimensions</a></td>
<td>rows(A)<br />
columns(A)</td>
<td>dim(A)[1]<br />
dim(A)[2]</td>
<td>nrows, ncols = A.shape</td>
<td>nrows, ncols = size([1 2 3; 4 5 6])</td>
</tr>
<tr>
<td><a href="#matrix-access">element access</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>A(1, 1)</td>
<td>A[1, 1]</td>
<td>A[0, 0]</td>
<td>A[1, 1]</td>
</tr>
<tr>
<td><a href="#matrix-row-access">row access</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>A(1, 1:2)</td>
<td>A[1, ]</td>
<td>A[0]</td>
<td>A[1, :]</td>
</tr>
<tr>
<td><a href="#matrix-column-access">column access</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>A(1:2, 1)</td>
<td>A[, 1]</td>
<td>A[:, 0]</td>
<td>A[:, 1]</td>
</tr>
<tr>
<td><a href="#submatrix-access">submatrix access</a></td>
<td>C = [1, 2, 3; 4, 5, 6; 7, 8, 9]<br />
C(1:2, 1:2)</td>
<td>C = matrix(seq(1, 9), 3, 3, byrow=T)<br />
C[1:2, 1:2]</td>
<td>A = np.matrix(range(1, 10)).reshape(3, 3)<br />
A[:2, :2]</td>
<td>reshape(1:9, 3, 3)[1:2, 1:2]</td>
</tr>
<tr>
<td><a href="#matrix-scalar-multiplication">scalar multiplication</a></td>
<td>3 * A<br />
A * 3<br />
<span style="color: gray"><em>also:</em></span><br />
3 .* A<br />
A .* 3</td>
<td>3 * A<br />
A * 3</td>
<td>3 * A<br />
A * 3</td>
<td>3 * [1 2; 3 4]<br />
[1 2; 3 4] * 3</td>
</tr>
<tr>
<td><a href="#matrix-element-wise-operators">element-wise operators</a></td>
<td>.+ .- .* ./</td>
<td>+ - * /</td>
<td>+ - np.multiply() np.divide()</td>
<td>+ - .* ./</td>
</tr>
<tr>
<td><a href="#matrix-multiplication">multiplication</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>A * B</td>
<td>A %*% B</td>
<td>np.dot(A, B)</td>
<td>A * B</td>
</tr>
<tr>
<td><a href="#matrix-power">power</a></td>
<td>A ^ 3<br />
<br />
<span style="color: gray">% power of each entry:</span><br />
A .^ 3</td>
<td> </td>
<td>A ** 3</td>
<td>A ^ 3<br />
<br />
<span style="color: gray"># power of each entry:</span><br />
A .^ 3</td>
</tr>
<tr>
<td><a href="#kronecker-product">kronecker product</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>kron(A, B)</td>
<td>kronecker(A, B)</td>
<td>np.kron(A, B)</td>
<td>kron(A, B)</td>
</tr>
<tr>
<td><a href="#matrix-comparison">comparison</a></td>
<td> all(all(A == B))<br />
any(any(A ~= B))</td>
<td>all(A == B)<br />
any(A != B)</td>
<td>np.all(A == B)<br />
np.any(A != B)</td>
<td>A == B<br />
A != B</td>
</tr>
<tr>
<td><a href="#matrix-norms">norms</a></td>
<td>norm(A, 1)<br />
norm(A, 2)<br />
norm(A, Inf)<br />
norm(A, &#x27;fro&#x27;)</td>
<td>norm(A, &quot;1&quot;)<br />
<span style="color: gray"><em>??</em></span><br />
norm(A, &quot;I&quot;)<br />
norm(A, &quot;F&quot;)</td>
<td> </td>
<td>norm(A, 1)<br />
norm(A, 2)<br />
norm(A, Inf)<br />
<span style="color: gray"># Froebenius norm:</span><br />
vecnorm(A, 2)</td>
</tr>
<tr>
<td><a href="#matrix-transpose">transpose</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>transpose(A)</td>
<td>t(A)</td>
<td>A.transpose()</td>
<td>transpose([1 2; 3 4])</td>
</tr>
<tr>
<td><a href="#matrix-conjugate-transpose">conjugate transpose</a></td>
<td> A = [1i, 2i; 3i, 4i]<br />
A&#x27;</td>
<td>A = matrix(c(1i, 2i, 3i, 4i), nrow=2, byrow=T)<br />
Conj(t(A))</td>
<td>A = np.matrix([[1j, 2j], [3j, 4j]])<br />
A.conj().transpose()</td>
<td>[1im 2im; 3im 4im]&#x27;<br />
ctranspose([1im 2im; 3im 4im])</td>
</tr>
<tr>
<td><a href="#matrix-inverse">inverse</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>inv(A)</td>
<td>solve(A)</td>
<td>np.linalg.inv(A)</td>
<td>inv([1 2; 3 4])</td>
</tr>
<tr>
<td><a name="pseudoinverse"></a><a href="#pseudoinverse-note">pseudoinverse</a></td>
<td>A = [0 1; 0 0]<br />
<br />
pinv(A)</td>
<td>install.packages(&#x27;corpcor&#x27;)<br />
library(corpcor)<br />
<br />
A = matrix(c(0, 0, 1, 0), nrow=2)<br />
pseudoinverse(A)</td>
<td>A = np.matrix([[0, 1], [0, 0]])<br />
<br />
np.linalg.pinv(A)</td>
<td>pinv([0 1; 0 0])</td>
</tr>
<tr>
<td><a href="#matrix-determinant">determinant</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>det(A)</td>
<td>det(A)</td>
<td>np.linalg.det(A)</td>
<td>det(1 2; 3 4])</td>
</tr>
<tr>
<td><a href="#matrix-trace">trace</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>trace(A)</td>
<td>sum(diag(A))</td>
<td>A.trace()</td>
<td>trace([1 2; 3 4])</td>
</tr>
<tr>
<td><a href="#matrix-eigenvalues">eigenvalues</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td>eig(A)</td>
<td>eigen(A)$values</td>
<td>np.linalg.eigvals(A)</td>
<td>eigvals(A)</td>
</tr>
<tr>
<td><a href="#matrix-eigenvectors">eigenvectors</a></td>
<td>[evec, eval] = eig(A)<br />
<span style="color: gray">% each column of evec is an eigenvector</span><br />
<span style="color: gray">% eval is a diagonal matrix of eigenvalues</span></td>
<td>eigen(A)$vectors</td>
<td>np.linalg.eig(A)[1]</td>
<td>eigvecs(A)</td>
</tr>
<tr>
<td><a name="svd"></a><a href="#svd-note">singular value decomposition</a></td>
<td>X = randn(10)<br />
<br />
[u, d, v] = svd(X)</td>
<td>X = matrix(rnorm(100), nrow=10)<br />
result = svd(X)<br />
<br />
<span style="color: gray"># singular values:</span><br />
result$d<br />
<br />
<span style="color: gray"># matrix of eigenvectors:</span><br />
result$u<br />
<br />
<span style="color: gray"># unitary matrix:</span><br />
result$v</td>
<td>np.linalg.svd(np.random.randn(100).reshape(10, 10))</td>
<td>X = randn(10, 10)<br />
<br />
u, s, v = svds(X)</td>
</tr>
<tr>
<td><a href="#matrix-solution">solve system of equations</a></td>
<td> A \ [2;3]</td>
<td>solve(A, c(2, 3))</td>
<td>np.linalg.solve(A, [2, 3])</td>
<td>[1 2; 3 4] \ [2; 3]</td>
</tr>
<tr>
<th colspan="5"><a name="sparse-matrices"></a><a href="#sparse-matrices-note">sparse matrices</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="sparse-matrix-construction"></a><a href="#sparse-matrix-construction-note">sparse matrix construction</a></td>
<td><span style="color: gray">% 100x100 matrix with 5 at (1, 1) and 4 at (2, 2):</span><br />
X = sparse([1 2], [1 2], [5 4], 100, 100)</td>
<td>X = spMatrix(100, 100, c(1, 2), c(1, 2), c(5, 4))</td>
<td>import scipy.sparse as sparse<br />
<br />
row, col, val = [5, 4], [1, 2], [1, 2]<br />
X = sparse.coo_matrix((val, (row, col)), shape=(100, 100))</td>
<td> </td>
</tr>
<tr>
<td><a name="sparse-matrix-decomposition"></a><a href="#sparse-matrix-decomposition-note">sparse matrix decomposition</a></td>
<td>[rows, cols, vals] = find(X)<br />
<br />
<span style="color: gray">% just the values:</span><br />
nonzeros(X)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="sparse-identity-matrix"></a><a href="#sparse-identity-matrix-note">sparse identity matrix</a></td>
<td><span style="color: gray">% 100x100 identity:</span><br />
speye(100)</td>
<td> </td>
<td>sparse.identity(100)<br />
<br />
<span style="color: gray"># not square; ones on diagonal:</span><br />
sparse.eye(100, 200)</td>
<td> </td>
</tr>
<tr>
<td><a name="dense-matrix-to-sparse-matrix"></a><a href="#dense-matrix-to-sparse-matrix-note">dense matrix to sparse matrix</a><br />
<span style="color: gray"><em>and back</em></span></td>
<td>X = sparse([1 0 0; 0 0 0; 0 0 0])<br />
X2 = full(X)</td>
<td> </td>
<td>imoprt scipy.sparse as sparse<br />
<br />
A = np.array([[1, 0, 0], [0, 0, 0], [0, 0, 0]])<br />
X = sparse.coo_matrix(A)<br />
X2 = X.todense()</td>
<td> </td>
</tr>
<tr>
<td><a name="sparse-matrix-storage"></a><a href="#sparse-matrix-storage-note">sparse matrix storage</a></td>
<td><span style="color: gray">% is storage sparse:</span><br />
issparse(X)<br />
<br />
<span style="color: gray">% memory allocation in bytes:</span><br />
nzmax(X)<br />
<br />
<span style="color: gray">% number of nonzero entries:</span><br />
nnz(X)</td>
<td><span style="color: gray"># memory allocation in bytes:</span><br />
object.size(X)</td>
<td>import scipy.sparse as sparse<br />
<br />
sparse.issparse(X)</td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="optimization"></a><a href="#optimization-note">optimization</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="linear-min"></a><a href="#linear-min-note">linear minimization</a></td>
<td><span style="color: gray">% download and install cvx:</span><br />
cvx_begin<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x2;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x3;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>minimize x1 + x2 + x3;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>subject to<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x1 + x2 &gt;= 1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x2 + x3 &gt;= 1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x1 + x3 &gt;= 1;<br />
cvx_end;<br />
<br />
<span style="color: gray">% &#x27;Solved&#x27; in cvx_status</span><br />
<span style="color: gray">% argmin in x1, x2, x3</span><br />
<span style="color: gray">% minval in cvx_optval</span></td>
<td><span style="color: gray"># install.packages(&#x27;lpSolve&#x27;)</span><br />
require(lpSolve)<br />
<br />
obj = c(1, 1, 1)<br />
A = matrix(c(1, 1, 0, 0, 1, 1, 1, 0, 1),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>nrow=3, byrow=T)<br />
dir = c(&quot;&gt;=&quot;, &quot;&gt;=&quot;, &quot;&gt;=&quot;)<br />
rhs = c(1, 1, 1)<br />
result = lp(&quot;min&quot;, obj, A, dir, rhs)<br />
<br />
<span style="color: gray"># 0 in result$status</span><br />
<span style="color: gray"># argmin in result$solution</span><br />
<span style="color: gray"># minval in result$objval</span></td>
<td><span style="color: gray"># sudo pip install cvxopt</span><br />
from cvxopt.modeling import *<br />
<br />
x1 = variable(1, &#x27;x1&#x27;)<br />
x2 = variable(1, &#x27;x2&#x27;)<br />
x3 = variable(1, &#x27;x3&#x27;)<br />
c1 = (x1 + x2 &gt;= 1)<br />
c2 = (x1 + x3 &gt;= 1)<br />
c3 = (x2 + x3 &gt;= 1)<br />
lp = op(x1 + x2 + x3, [c1, c2, c3])<br />
lp.solve()<br />
<br />
<span style="color: gray"># &#x27;optimal&#x27; in lp.status</span><br />
<span style="color: gray"># argmin in x1.value[0], x2.value[0],<br />
#<span style="white-space: pre-wrap;">&nbsp;&nbsp;&nbsp;</span>x3.value[0]</span><br />
<span style="color: gray"># minval in lp.objective.value()[0]</span></td>
<td> </td>
</tr>
<tr>
<td><a name="decision-var-vec"></a><a href="#decision-var-vec-note">decision variable vector</a></td>
<td>cvx_begin<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x(3);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>minimize sum(x);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>subject to<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(1) + x(2) &gt;= 1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(2) + x(3) &gt;= 1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(1) + x(3) &gt;= 1;<br />
cvx_end;</td>
<td><span style="color: gray"># decision variables must be an array</span></td>
<td><span style="color: gray"># sudo pip install cvxopt</span><br />
from cvxopt.modeling import *<br />
<br />
x = variable(3, &#x27;x&#x27;)<br />
c1 = (x[0] + x[1] &gt;= 1)<br />
c2 = (x[0] + x[2] &gt;= 1)<br />
c3 = (x[1] + x[2] &gt;= 1)<br />
lp = op(x[0] + x[1] + x[2], [c1, c2, c3])<br />
lp.solve()</td>
<td> </td>
</tr>
<tr>
<td><a name="linear-max"></a><a href="#linear-max-note">linear maximization</a></td>
<td>cvx_begin<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x(3);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>maximize sum(x);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>subject to<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(1) + x(2) &lt;= 1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(2) + x(3) &lt;= 1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(1) + x(3) &lt;= 1;<br />
cvx_end;</td>
<td><span style="color: gray"># install.packages(&#x27;lpSolve&#x27;)</span><br />
require(lpSolve)<br />
<br />
obj = c(1, 1, 1)<br />
A = matrix(c(1, 1, 0, 0, 1, 1, 1, 0, 1),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>nrow=3, byrow=T)<br />
dir = c(&quot;&lt;=&quot;, &quot;&lt;=&quot;, &quot;&lt;=&quot;)<br />
rhs = c(1, 1, 1)<br />
result = lp(&quot;max&quot;, obj, A, dir, rhs)</td>
<td><span style="color: gray"># None; negate objective function before<br />
# solving; negate optimal value which<br />
# is found.</span></td>
<td> </td>
</tr>
<tr>
<td><a name="var-declaration-constraint"></a><a href="#var-declaration-constraint-note">constraint in variable declaration</a></td>
<td>cvx_begin<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x(3) nonnegative;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>minimize 10*x(1) + 5*x(2) + 4*x(3);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>subject to<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(1) + x(2) + x(3) &gt;= 10;<br />
cvx_end</td>
<td><span style="color: gray"># none; but note that variables are assumed<br />
# to be nonnegative</span></td>
<td><span style="color: gray"># none</span></td>
<td> </td>
</tr>
<tr>
<td><a name="opt-unbounded-behavior"></a><a href="#opt-unbounded-behavior-note">unbounded behavior</a></td>
<td>cvx_begin<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x(3);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>maximize sum(x);<br />
cvx_end<br />
<br />
<span style="color: gray">% Inf in cvx_optval</span><br />
<span style="color: gray">% &#x27;Unbounded&#x27; in cvx_status</span></td>
<td><span style="color: gray"># install.packages(&#x27;lpSolve&#x27;)</span><br />
require(lpSolve)<br />
<br />
obj = c(1, 1, 1)<br />
A = matrix(c(1, 1, 1), nrow=1, byrow=T)<br />
dir = c(&quot;&gt;=&quot;)<br />
rhs = c(1)<br />
result = lp(&quot;max&quot;, obj, A, dir, rhs)<br />
<br />
<span style="color: gray"># result$status is 3</span></td>
<td><span style="color: gray"># sudo pip install cvxopt</span><br />
from cvxopt.modeling import *<br />
<br />
x = variable(3, &#x27;x&#x27;)<br />
c1 = (x[0] &gt;= 0)<br />
c2 = (x[1] &gt;= 0)<br />
c3 = (x[2] &lt;= 0)<br />
lp = op(x[0] + x[1] + x[2], [c1, c2, c3])<br />
lp.solve()<br />
<br />
<span style="color: gray"># lp.status is &#x27;dual infeasible&#x27;</span></td>
<td> </td>
</tr>
<tr>
<td><a name="opt-infeasible-behavior"></a><a href="#opt-infeasible-behavior-note">infeasible behavior</a></td>
<td>cvx_begin<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>variable x(3) nonnegative;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>maximize sum(x);<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>subject to<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x(1) + x(2) + x(3) &lt; -1;<br />
cvx_end<br />
<br />
<span style="color: gray">% -Inf in cvx_optval</span><br />
<span style="color: gray">% &#x27;Infeasible&#x27; in cvx_status</span></td>
<td><span style="color: gray"># install.packages(&#x27;lpSolve&#x27;)</span><br />
require(lpSolve)<br />
<br />
obj = c(1, 1, 1)<br />
A = matrix(c(1, 1, 1), nrow=1, byrow=T)<br />
dir = c(&quot;&lt;=&quot;)<br />
rhs = c(-1)<br />
result = lp(&quot;min&quot;, obj, A, dir, rhs)<br />
<br />
<span style="color: gray"># result$status is 2</span></td>
<td><span style="color: gray"># sudo pip install cvxopt</span><br />
from cvxopt.modeling import *<br />
<br />
x = variable(3, &#x27;x&#x27;)<br />
c1 = (x[0] &gt;= 0)<br />
c2 = (x[1] &gt;= 0)<br />
c3 = (x[2] &gt;= 0)<br />
c4 = (x[0] + x[1] + x[2] &lt;= -1)<br />
lp = op(x[0] + x[1] + x[2], [c1, c2, c3, c4])<br />
lp.solve()<br />
<br />
<span style="color: gray"># lp.status is &#x27;primal infeasible&#x27;</span></td>
<td> </td>
</tr>
<tr>
<td><a name="int-decision-var"></a><a href="#int-decision-var-note">integer decision variable</a></td>
<td><span style="color: gray">% requires Optimization Toolbox:</span><br />
f = [1 1 1]<br />
A = [-1 -1 0; -1 0 -1; 0 -1 -1;<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>-1 0 0; 0 -1 0; 0 0 -1]<br />
b = [-1 -1 -1 0 0 0]<br />
<span style="color: gray">% 2nd arg indicates integer vars</span><br />
[x opt flag] = intlinprog(f, [1 1 1], A, b)<br />
<br />
<span style="color: gray">% if solution found, flag is 1</span><br />
<span style="color: gray">% x is argmin </span><br />
<span style="color: gray">% opt is optimal value</span></td>
<td><span style="color: gray"># install.packages(&#x27;lpSolve&#x27;)</span><br />
require(lpSolve)<br />
<br />
obj = c(1, 1, 1)<br />
A = matrix(c(1, 1, 0, 0, 1, 1, 1, 0, 1),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>nrow=3, byrow=T)<br />
dir = c(&quot;&gt;=&quot;, &quot;&gt;=&quot;, &quot;&gt;=&quot;)<br />
rhs = c(1, 1, 1)<br />
result = lp(&quot;min&quot;, obj, A, dir, rhs,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>int.vec=c(1, 1, 1))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="binary-decision-var"></a><a href="#binary-decision-var-note">binary decision variable</a></td>
<td> </td>
<td><span style="color: gray"># install.packages(&#x27;lpSolve&#x27;)</span><br />
require(lpSolve)<br />
<br />
obj = c(1, 1, 1)<br />
A = matrix(c(1, 1, 0, 0, 1, 1, 1, 0, 1),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>nrow=3, byrow=T)<br />
dir = c(&quot;&gt;=&quot;, &quot;&gt;=&quot;, &quot;&gt;=&quot;)<br />
rhs = c(1, 1, 1)<br />
result = lp(&quot;min&quot;, obj, A, dir, rhs,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>binary.vec=c(1, 1, 1))</td>
<td><span style="color: gray"># integer solver not provided by default</span></td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="polynomials"></a><a href="#polynomials-note">polynomials</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td>exact polynomial fit</td>
<td>x = [1 2 3 4]<br />
y = [3 9 2 1]<br />
<span style="color: gray">% polynomial coefficient array:</span><br />
p = polyfit(x, y, 3)<br />
<br />
<span style="color: gray">% plot polynomial:</span><br />
xx = -10:.1:10<br />
yy = polyval(p, xx)<br />
plot(xx, yy)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>exact polynomial fit with derivative values</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>piecewise polynomial fit</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="cubic-spline"></a><img src="http://cdn.hyperpolyglot.org/images/cubic-spline.jpg" alt="http://cdn.hyperpolyglot.org/images/cubic-spline.jpg" class="image" /><br />
<a href="#cubic-spline-note">cubic spline</a></td>
<td>f = spline(1:20, normrnd(0, 1, 1, 20))<br />
x = 1:.1:20<br />
plot(x, ppval(f, x))</td>
<td>f = splinefun(rnorm(20))<br />
x = seq(1, 20, .1)<br />
plot(x, f(x), type=&quot;l&quot;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>underdetermined polynomail fit</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>overdetermined polynomial fit</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>multivariate polynomial fit</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="descriptive-statistics"></a><a href="#descriptive-statistics-note">descriptive statistics</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="first-moment-stats"></a><a href="#first-moment-stats-note">first moment statistics</a></td>
<td>x = [1 2 3 8 12 19]<br />
<br />
sum(x)<br />
mean(x)</td>
<td>x = c(1,2,3,8,12,19)<br />
<br />
sum(x)<br />
mean(x)</td>
<td>x = [1,2,3,8,12,19]<br />
<br />
sp.sum(x)<br />
sp.mean(x)</td>
<td>x = [1 2 3 8 12 19]<br />
<br />
sum(x)<br />
mean(x)</td>
</tr>
<tr>
<td><a name="second-moment-stats"></a><a href="#second-moment-stats-note">second moment statistics</a></td>
<td>std(x, 1)<br />
var(x, 1)</td>
<td>n = length(x)<br />
<br />
sd(x) * sqrt((n-1)/n)<br />
var(x) * (n-1)/n</td>
<td>sp.std(x)<br />
sp.var(x)</td>
<td> </td>
</tr>
<tr>
<td><a name="second-moment-stats-sample"></a><a href="#second-moment-stats-sample-note">second moment statistics for samples</a></td>
<td>std(x)<br />
var(x)</td>
<td>sd(x)<br />
var(x)</td>
<td>n = float(len(x))<br />
<br />
sp.std(x) * math.sqrt(n/(n-1))<br />
sp.var(x) * n/(n-1)</td>
<td>std(x)<br />
var(x)</td>
</tr>
<tr>
<td><a name="skewness"></a><a href="#skewness-note">skewness</a></td>
<td><span style="color: gray"><em>Octave uses sample standard deviation to compute skewness:</em></span><br />
skewness(x)</td>
<td>install.packages(&#x27;moments&#x27;)<br />
library(&#x27;moments&#x27;)<br />
<br />
skewness(x)</td>
<td>stats.skew(x)</td>
<td> </td>
</tr>
<tr>
<td><a name="kurtosis"></a><a href="#kurtosis-note">kurtosis</a></td>
<td><span style="color: gray"><em>Octave uses sample standard deviation to compute kurtosis:</em></span><br />
kurtosis(x)</td>
<td>install.packages(&#x27;moments&#x27;)<br />
library(&#x27;moments&#x27;)<br />
<br />
kurtosis(x) - 3</td>
<td>stats.kurtosis(x)</td>
<td> </td>
</tr>
<tr>
<td><a name="nth-moment"></a><a href="#nth-moment-note">nth moment and nth central moment</a></td>
<td>n = 5<br />
<br />
moment(x, n)<br />
moment(x, n, &quot;c&quot;)</td>
<td>install.packages(&#x27;moments&#x27;)<br />
library(&#x27;moments&#x27;)<br />
<br />
n = 5<br />
moment(x, n)<br />
moment(x, n, central=T)</td>
<td>n = 5<br />
<br />
<span style="color: gray"><em>??</em></span><br />
stats.moment(x, n)</td>
<td> </td>
</tr>
<tr>
<td><a name="mode"></a><a href="#mode-note">mode</a></td>
<td>mode([1 2 2 2 3 3 4])</td>
<td>samp = c(1,2,2,2,3,3,4)<br />
names(sort(-table(samp)))[1]</td>
<td>stats.mode([1,2,2,2,3,3,4])[0][0]</td>
<td> </td>
</tr>
<tr>
<td><a name="quantile-stats"></a><a href="#quantile-stats-note">quantile statistics</a></td>
<td>min(x)<br />
median(x)<br />
max(x)<br />
iqr(x)<br />
quantile(x, .90)</td>
<td>min(x)<br />
median(x)<br />
max(x)<br />
IQR(x)<br />
quantile(x, prob=.90)</td>
<td>min(x)<br />
sp.median(x)<br />
max(x)<br />
<span style="color: gray"><em>??</em></span><br />
stats.scoreatpercentile(x, 90.0)</td>
<td> </td>
</tr>
<tr>
<td><a name="bivariate-stats"></a><a href="#bivariate-stats-note">bivariate statistiscs</a><br />
<span style="color: gray"><em>correlation, covariance</em></span></td>
<td>x = [1 2 3]<br />
y = [2 4 7]<br />
<br />
cor(x, y)<br />
cov(x, y)</td>
<td>x = c(1,2,3)<br />
y = c(2,4,7)<br />
<br />
cor(x, y)<br />
cov(x, y)</td>
<td>x = [1,2,3]<br />
y = [2,4,7]<br />
<br />
stats.linregress(x, y)[2]<br />
<span style="color: gray"><em>??</em></span></td>
<td> </td>
</tr>
<tr>
<td><a name="correlation-matrix"></a><a href="#correlation-matrix-note">correlation matrix</a></td>
<td>x1 = randn(100, 1)<br />
x2 = 0.5 * x1 + randn(100, 1)<br />
x3 = 0.1 * x1 + 0.1 * x2 + 0.1 * randn(100, 1)<br />
<br />
corr([x1 x2 x3])</td>
<td>x1 = rnorm(100)<br />
x2 = x1 + 0.5 * rnorm(100)<br />
x3 = 0.3 * x1 + 0.1 * 2 + 0.1 * rnorm(100)<br />
<br />
cor(cbind(x1, x2, x3))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="freq-table"></a><a href="#freq-table-note">data set to frequency table</a></td>
<td> </td>
<td>x = c(1,2,1,1,2,5,1,2,7)<br />
tab = table(x)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="invert-freq-table"></a><a href="#invert-freq-table-note">frequency table to data set</a></td>
<td> </td>
<td>rep(as.integer(names(tab)),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>unname(tab))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="bin"></a><a href="#bin-note">bin</a></td>
<td> </td>
<td>x = c(1.1, 3.7, 8.9, 1.2, 1.9, 4.1)<br />
xf = cut(x, breaks=c(0, 3, 6, 9))<br />
<span style="color: gray"># bins are (0, 3], (3, 6], and (6, 9]:</span><br />
bins = tapply(x, xf, length)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="distributions"></a><a href="#distribution-note">distributions</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="binomial"></a><a href="#binomial-note">binomial</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>binopdf(x, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
binocdf(x, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
binoinv(y, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
binornd(<span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>, 1, 10)</td>
<td>dbinom(x, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
pbinom(x, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
qbinom(y, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
rbinom(10, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)</td>
<td>stats.binom.pmf(x, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
stats.binom.cdf(x, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
stats.binom.ppf(y, <span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)<br />
stats.binom.rvs(<span style="color: gray"><em>n</em></span>, <span style="color: gray"><em>p</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="poisson"></a><a href="#poisson-note">poisson</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>poisspdf(x, <span style="color: gray"><em>lambda</em></span>)<br />
poisscdf(x, <span style="color: gray"><em>lambda</em></span>)<br />
poissinv(y, <span style="color: gray"><em>lambda</em></span>)<br />
poissrnd(<span style="color: gray"><em>lambda</em></span>, 1, 10)</td>
<td>dpois(x, <span style="color: gray"><em>lambda</em></span>)<br />
ppois(x, <span style="color: gray"><em>lambda</em></span>)<br />
qpois(y, <span style="color: gray"><em>lambda</em></span>)<br />
rpois(10, <span style="color: gray"><em>lambda</em></span>)</td>
<td>stats.poisson.pmf(x, <span style="color: gray"><em>lambda</em></span>)<br />
stats.poisson.cdf(x, <span style="color: gray"><em>lambda</em></span>)<br />
stats.poisson.ppf(y, <span style="color: gray"><em>lambda</em></span>)<br />
stats.poisson.rvs(<span style="color: gray"><em>lambda</em></span>, size=1)</td>
<td> </td>
</tr>
<tr>
<td><a name="normal"></a><a href="#normal-note">normal</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>normpdf(x, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
normcdf(x, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
norminv(y, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
normrnd(<span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>, 1, 10)</td>
<td>dnorm(x, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
pnorm(x, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
qnorm(y, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
rnorm(10, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)</td>
<td>stats.norm.pdf(x, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
stats.norm.cdf(x, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
stats.norm.ppf(y, <span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)<br />
stats.norm.rvs(<span style="color: gray"><em>mu</em></span>, <span style="color: gray"><em>sigma</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="gamma"></a><a href="#gamma-note">gamma</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>gampdf(x, <span style="color: gray"><em>k</em></span>, <span style="color: gray"><em>theta</em></span>)<br />
gamcdf(x, <span style="color: gray"><em>k</em></span>, <span style="color: gray"><em>theta</em></span>)<br />
gaminv(y, <span style="color: gray"><em>k</em></span>, <span style="color: gray"><em>theta</em></span>)<br />
gamrnd(<span style="color: gray"><em>k</em></span>, <span style="color: gray"><em>theta</em></span>, 1, 10)</td>
<td>dgamma(x, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)<br />
pgamma(x, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)<br />
qgamma(y, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)<br />
rgamma(10, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)</td>
<td>stats.gamma.pdf(x, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)<br />
stats.gamma.cdf(x, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)<br />
stats.gamma.ppf(y, <span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)<br />
stats.gamma.rvs(<span style="color: gray"><em>k</em></span>, scale=<span style="color: gray"><em>theta</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="exponential"></a><a href="#exponential-note">exponential</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>exppdf(x, <span style="color: gray"><em>lambda</em></span>)<br />
expcdf(x, <span style="color: gray"><em>lambda</em></span>)<br />
expinv(y, <span style="color: gray"><em>lambda</em></span>)<br />
exprnd(<span style="color: gray"><em>lambda</em></span>, 1, 10)</td>
<td>dexp(x, <span style="color: gray"><em>lambda</em></span>)<br />
pexp(x, <span style="color: gray"><em>lambda</em></span>)<br />
qexp(y, <span style="color: gray"><em>lambda</em></span>)<br />
rexp(10, <span style="color: gray"><em>lambda</em></span>)</td>
<td>stats.expon.pdf(x, scale=1.0/<span style="color: gray"><em>lambda</em></span>)<br />
stats.expon.cdf(x, scale=1.0/<span style="color: gray"><em>lambda</em></span>)<br />
stats.expon.ppf(x, scale=1.0/<span style="color: gray"><em>lambda</em></span>)<br />
stats.expon.rvs(scale=1.0/<span style="color: gray"><em>lambda</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="chi-squared"></a><a href="#chi-squared-note">chi-squared</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>chi2pdf(x, <span style="color: gray"><em>nu</em></span>)<br />
chi2cdf(x, <span style="color: gray"><em>nu</em></span>)<br />
chi2inv(y, <span style="color: gray"><em>nu</em></span>)<br />
chi2rnd(<span style="color: gray"><em>nu</em></span>, 1, 10)</td>
<td>dchisq(x, <span style="color: gray"><em>nu</em></span>)<br />
pchisq(x, <span style="color: gray"><em>nu</em></span>)<br />
qchisq(y, <span style="color: gray"><em>nu</em></span>)<br />
rchisq(10, <span style="color: gray"><em>nu</em></span>)</td>
<td>stats.chi2.pdf(x, <span style="color: gray"><em>nu</em></span>)<br />
stats.chi2.cdf(x, <span style="color: gray"><em>nu</em></span>)<br />
stats.chi2.ppf(y, <span style="color: gray"><em>nu</em></span>)<br />
stats.chi2.rvs(<span style="color: gray"><em>nu</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="beta"></a><a href="#beta-note">beta</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>betapdf(x, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
betacdf(x, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
betainvf(y, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
betarnd(<span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>, 1, 10)</td>
<td>dbeta(x, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
pbeta(x, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
qbeta(y, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
rbeta(10, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)</td>
<td>stats.beta.pdf(x, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
stats.beta.cdf(x, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
stats.beta.ppf(y, <span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)<br />
stats.beta.pvs(<span style="color: gray"><em>alpha</em></span>, <span style="color: gray"><em>beta</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="uniform"></a><a href="#uniform-note">uniform</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>unifpdf(x, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
unifcdf(x, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
unifinv(y, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
unifrnd(<span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>, 1, 10)</td>
<td>dunif(x, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
punif(x, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
qunif(y, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
runif(10, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)</td>
<td>stats.uniform.pdf(x, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
stats.uniform.cdf(x, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
stats.uniform.ppf(y, <span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)<br />
stats.unifrom.rvs(<span style="color: gray"><em>a</em></span>, <span style="color: gray"><em>b</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="students-t"></a><a href="#students-t-note">Student's t</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>tpdf(x, <span style="color: gray"><em>nu</em></span>)<br />
tcdf(x, <span style="color: gray"><em>nu</em></span>)<br />
tinv(y, <span style="color: gray"><em>nu</em></span>)<br />
trnd(<span style="color: gray"><em>nu</em></span>, 1, 10)</td>
<td>dt(x, <span style="color: gray"><em>nu</em></span>)<br />
pt(x, <span style="color: gray"><em>nu</em></span>)<br />
qt(y, <span style="color: gray"><em>nu</em></span>)<br />
rt(10, <span style="color: gray"><em>nu</em></span>)</td>
<td>stats.t.pdf(x, <span style="color: gray"><em>nu</em></span>)<br />
stats.t.cdf(x, <span style="color: gray"><em>nu</em></span>)<br />
stats.t.ppf(y, <span style="color: gray"><em>nu</em></span>)<br />
stats.t.rvs(<span style="color: gray"><em>nu</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="snedecors-f"></a><a href="#snedecors-f-note">Snedecor's F</a><br />
<span style="color: gray"><em>density, cumulative, quantile,<br />
sample of 10</em></span></td>
<td>fpdf(x, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
fcdf(x, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
finv(y, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
frnd(<span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>, 1, 10)</td>
<td>df(x, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
pf(x, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
qf(y, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
rf(10, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)</td>
<td>stats.f.pdf(x, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
stats.f.cdf(x, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
stats.f.ppf(y, <span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)<br />
stats.f.rvs(<span style="color: gray"><em>d1</em></span>, <span style="color: gray"><em>d2</em></span>)</td>
<td> </td>
</tr>
<tr>
<td><a name="empirical-density-func"></a><a href="#empirical-density-func-note">empirical density function</a></td>
<td><span style="color: gray">% $ apt-get install octave-econometrics</span><br />
<br />
x = (-3:.05:3)&#x27;<br />
y = kernel_density(x, normrnd(0, 1, 100, 1))</td>
<td>dfunc = density(rnorm(100))<br />
<br />
dfunc$x<br />
dfunc$y</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="empirical-cumulative-distribution"></a><a href="#empirical-cumulative-distribution-note">empirical cumulative distribution</a></td>
<td> </td>
<td><span style="color: gray"><em>F is a right-continuous step function:</em></span><br />
F = ecdf(rnorm(100))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="empirical-quantile-func"></a><a href="#empirical-quantile-func-note">empirical quantile function</a></td>
<td> </td>
<td>F = ecdf(rnorm(100))<br />
Finv = ecdf(F(seq(0, 1, .01)))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="linear-regression"></a><a href="#linear-regression-note">linear regression</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="simple-linear-regression"></a><a href="#simple-linear-regression-note">simple linear regression</a><br />
<span style="color: gray"><em>coefficient, intercept, and residuals</em></span></td>
<td>x = [1 2 3]<br />
y = [2 4 7]<br />
<br />
[lsq, res] = polyfit(x, y, 1)<br />
a = lsq(1)<br />
b = lsq(2)<br />
y - (a*x+b)</td>
<td>x = seq(10)<br />
y = 2 * x + 1 + rnorm(10)<br />
<br />
fit = lm(y ~ x)<br />
summary(fit)<br />
<br />
<span style="color: gray"># yhat = ax + b:</span><br />
a = fit$coefficients[2]<br />
b = fit$coefficients[1]<br />
<br />
<span style="color: gray"># y - (ax + b):</span><br />
fit$residuals</td>
<td>x = np.array([1,2,3])<br />
y = np.array([2,4,7])<br />
<br />
lsq = stats.linregress(x, y)<br />
a = lsq[0]<br />
b = lsq[1]<br />
y - (a*x+b)</td>
<td> </td>
</tr>
<tr>
<td><a name="linear-regression-no-intercept"></a><a href="#linear-regression-no-intercept-note">no intercept</a></td>
<td> </td>
<td>x = seq(10)<br />
y = 2 * x + 1 + rnorm(10)<br />
<br />
fit = lm(y ~ x + 0)<br />
summary(fit)<br />
<br />
<span style="color: gray"># y = ax:</span><br />
a = fit$coefficients[1]</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="multiple-linear-regression"></a><a href="#multiple-linear-regression-note">multiple linear regression</a></td>
<td> </td>
<td>x1 = rnorm(100)<br />
x2 = rnorm(100)<br />
y = 2 * x2 + rnorm(100)<br />
<br />
fit = lm(y ~ x1 + x2)<br />
summary(fit)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="linear-regression-interaction"></a><a href="#linear-regression-interaction-note">interaction</a></td>
<td> </td>
<td>x1 = rnorm(100)<br />
x2 = rnorm(100)<br />
y = 2 * x1 + x2 + 3 * x1 * x2 + rnorm(100)<br />
<br />
<span style="color: gray"># x1, x2, and x1*x2 as predictors:</span><br />
fit = lm(y ~ x1 * x2)<br />
summary(fit)<br />
<br />
<span style="color: gray"># just x1*x2 as predictor:</span><br />
fit2 = lm(Y ~ x1:x2)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="logistic-regression"></a><a href="#logistic-regression-note">logistic regression</a></td>
<td> </td>
<td>y = round(runif(100))<br />
x1 = round(runif(100))<br />
x2 = y + rnorm(100)<br />
<br />
fit = glm(y ~ x1 + x2, family=&quot;binomial&quot;)<br />
summary(fit)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="statistical-tests"></a><a href="#statistical-tests-note">statistical tests</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="wilcoxon"></a><a href="#wilcoxon-note">wilcoxon signed-rank test</a><br />
<span style="color: gray"><em>variable is symmetric around zero</em></span></td>
<td>x = unifrnd(-0.5, 0.5, 100, 1)<br />
<br />
<span style="color: gray">% null hypothesis is true:</span><br />
wilcoxon_test(x, zeros(100, 1))<br />
<br />
<span style="color: gray">% alternative hypothesis is true:</span><br />
wilcoxon_test(x + 1.0, zeros(100, 1))</td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
wilcox.test(runif(100) - 0.5)<br />
<br />
<span style="color: gray">alternative hypothesis is true:</span><br />
wilcox.test(runif(100) + 0.5)</td>
<td>stats.wilcoxon()</td>
<td> </td>
</tr>
<tr>
<td><a name="kruskal"></a><a href="#kruskal-note">kruskal-wallis rank sum test</a><br />
<span style="color: gray"><em>variables have same location parameter</em></span></td>
<td>x = unifrnd(0, 1, 200, 1)<br />
<br />
<span style="color: gray">% null hypothesis is true:</span><br />
kruskal_wallis_test(randn(100, 1), randn(200, 1))<br />
<br />
<span style="color: gray">% alternative hypothesis is true:</span><br />
kruskal_wallis_test(randn(100, 1), x)</td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
kruskal.test(list(rnorm(100), rnorm(200)))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
kruskal.test(list(rnorm(100), runif(200)))</td>
<td>stats.kruskal()</td>
<td> </td>
</tr>
<tr>
<td><a name="kolmogorov-smirnov-test"></a><a href="#kolmogorov-smirnov-test-note">kolmogorov-smirnov test</a><br />
<span style="color: gray"><em>variables have same distribution</em></span></td>
<td>x = randn(100, 1)<br />
y1 = randn(100, 1)<br />
y2 = unifrnd(-0.5, 0.5, 100, 1)<br />
<br />
<span style="color: gray">% null hypothesis is true:</span><br />
kolmogorov_smirnov_test_2(x, y1)<br />
<br />
<span style="color: gray">% alternative hypothesis is true:</span><br />
kolmogorov_smirnov_test_2(x, y2)</td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
ks.test(rnorm(100), rnorm(100))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
ks.test(rnorm(100), runif(100) - 0.5)</td>
<td>stats.ks_2samp()</td>
<td> </td>
</tr>
<tr>
<td><a name="one-sample-t-test"></a><a href="#one-sample-t-test-note">one-sample t-test</a><br />
<span style="color: gray"><em>mean of normal variable with unknown variance is zero</em></span></td>
<td>x1 = 3 * randn(100, 1)<br />
x2 = 3 * randn(100, 1) + 3<br />
<br />
<span style="color: gray">% null hypothesis is true:</span><br />
t_test(x1, 0)<br />
<br />
<span style="color: gray">% alternative hypothesis is true:</span><br />
t_test(x2, 0)</td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
t.test(rnorm(100, 0, 3))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
t.test(rnorm(100, 3, 3))</td>
<td>stats.ttest_1samp()</td>
<td> </td>
</tr>
<tr>
<td><a name="independent-two-sample-t-test"></a><a href="#independent-two-sample-t-test-note">independent two-sample t-test</a><br />
<span style="color: gray"><em>two normal variables have same mean</em></span></td>
<td>x = randn(100, 1)<br />
y1 = randn(100, 1)<br />
y2 = randn(100, 1) + 1.5<br />
<br />
<span style="color: gray">% null hypothesis is true:</span><br />
t_test_2(x, y1)<br />
<br />
<span style="color: gray">% alternative hypothesis is true:</span><br />
t_test_2(x, y2)</td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
t.test(rnorm(100), rnorm(100))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
t.test(rnorm(100), rnorm(100, 3))</td>
<td>stats.ttest_ind()</td>
<td> </td>
</tr>
<tr>
<td><a name="one-sample-binomial-test"></a><a href="#one-sample-binomial-test-note">one-sample binomial test</a><br />
<span style="color: gray"><em>binomial variable parameter is as given</em></span></td>
<td> </td>
<td>n = 100<br />
x = rbinom(1, n, 0.5)<br />
<br />
<span style="color: gray"># null hypothesis that p=0.5 is true:</span><br />
binom.test(x, n)<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
binom.test(x, n, p=0.3)</td>
<td>stats.binom_test()</td>
<td> </td>
</tr>
<tr>
<td><a name="two-sample-binomial-test"></a><a href="#two-sample-binomial-test-note">two-sample binomial test</a><br />
<span style="color: gray"><em>parameters of two binomial variables are equal</em></span></td>
<td>prop_test_2()</td>
<td>n = 100<br />
x1 = rbinom(1, n, 0.5)<br />
x2 = rbinom(1, n, 0.5)<br />
<br />
<span style="color: gray"># null hypothesis that p=0.5 is true:</span><br />
prop.test(c(x1, x2), c(n, n))<br />
<br />
y = rbinom(1, n, 0.3)<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
prop.test(c(x1, y), c(n, n))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="chi-squared-test"></a><a href="#chi-squared-test-note">chi-squared test</a><br />
<span style="color: gray"><em>parameters of multinomial variable are all equal</em></span></td>
<td>chisquare_test_independence()</td>
<td>fair = floor(6 * runif(100)) + 1<br />
loaded = floor(7 * runif(100)) + 1<br />
loaded[which(loaded &gt; 6)] = 6<br />
<br />
<span style="color: gray"># null hypothesis is true:</span><br />
chisq.test(table(fair))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
chisq.test(table(loaded))</td>
<td>stats.chisquare()</td>
<td> </td>
</tr>
<tr>
<td><a name="poisson-test"></a><a href="#poisson-test-note">poisson test</a><br />
<span style="color: gray"><em>parameter of poisson variable is as given</em></span></td>
<td> </td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
poisson.test(rpois(1, 100), r=100)<br />
<br />
<span style="color: gray"># alternative test is true:</span><br />
poisson.test(rpois(1, 150), r=100)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="f-test"></a><a href="#f-test-note">F test</a><br />
<span style="color: gray"><em>ratio of variance of normal variables is as given</em></span></td>
<td>var_test()</td>
<td>x = rnorm(100)<br />
y = rnorm(100, 0, sd=sqrt(3))<br />
<br />
<span style="color: gray"># null hypothesis is true:</span><br />
var.test(y, x, ratio=3)<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
var.test(y, x, ratio=1)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="pearson-product-moment-test"></a><a href="#pearson-product-moment-test-note">pearson product moment test</a><br />
<span style="color: gray"><em>normal variables are not correlated</em></span></td>
<td>cor_test()</td>
<td>x1 = rnorm(100)<br />
x2 = rnorm(100)<br />
y = x2 + rnorm(100)<br />
<br />
<span style="color: gray"># null hypothesis is true:</span><br />
cor.test(y, x1)<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
cor.test(y, x2)</td>
<td>stats.pearsonr()</td>
<td> </td>
</tr>
<tr>
<td><a name="shapiro-wilk-test"></a><a href="#shapiro-wilk-test-note">shapiro-wilk test</a><br />
<span style="color: gray"><em>variable has normal distribution</em></span></td>
<td> </td>
<td><span style="color: gray"># null hypothesis is true:</span><br />
shapiro.test(rnorm(1000))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
shapiro.test(runif(1000))</td>
<td>stats.shapiro()</td>
<td> </td>
</tr>
<tr>
<td><a name="bartletts-test"></a><a href="#bartletts-test-note">bartlett's test</a><br />
<span style="color: gray"><em>two or more normal variables have same variance</em></span></td>
<td>bartlett_test()</td>
<td>x = rnorm(100)<br />
y1 = rnorm(100)<br />
y2 = 0.1 * rnorm(100)<br />
<br />
<span style="color: gray"># null hypothesis is true:</span><br />
bartlett.test(list(x, y1))<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
bartlett.test(list(x, y))</td>
<td>stats.bartlett()</td>
<td> </td>
</tr>
<tr>
<td><a name="levene-test"></a><a href="#levene-test-note">levene's test</a><br />
<span style="color: gray"><em>two or more variables have same variance</em></span></td>
<td> </td>
<td>install.packages(&#x27;reshape&#x27;, &#x27;car&#x27;)<br />
library(reshape) <br />
library(car)<br />
<br />
x = rnorm(100)<br />
y1 = rnorm(100)<br />
y2 = 0.1 * rnorm(100)<br />
<br />
<span style="color: gray"># null hypothesis is true:</span><br />
df = melt(data.frame(x, y1))<br />
leveneTest(df$value, df$variable)<br />
<br />
<span style="color: gray"># alternative hypothesis is true:</span><br />
df = melt(data.frame(x, y2))<br />
leveneTest(df$value, df$variable)</td>
<td>stats.levene()</td>
<td> </td>
</tr>
<tr>
<td><a name="one-way-anova"></a><a href="#one-way-anova-note">one-way anova</a><br />
<span style="color: gray"><em>two or more normal variables have same mean</em></span></td>
<td>x1 = randn(100, 1)<br />
x2 = randn(100, 1) <br />
x3 = randn(100, 1)<br />
x = [x1; x2; x3]<br />
y = [x1; x2; x3 + 0.5]<br />
units = ones(100, 1)<br />
grp = [units; 2 * units; 3 * units]<br />
<br />
<span style="color: gray">% null hypothesis is true:</span><br />
anova(x, grp)<br />
<br />
<span style="color: gray">% alternative hypothesis is true:</span><br />
anova(y, grp)</td>
<td>install.packages(&#x27;reshape&#x27;)<br />
library(reshape)<br />
<br />
<span style="color: gray"># null hypothesis that all means are the same<br />
# is true:</span><br />
x1 = rnorm(100)<br />
x2 = rnorm(100)<br />
x3 = rnorm(100)<br />
<br />
df = melt(data.frame(x1, x2, x3))<br />
fit = lm(df$value ~ df$variable)<br />
anova(fit)</td>
<td>stats.f_oneway()</td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="time-series"></a><a href="#time-series-note">time series</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="time-series-construction"></a><a href="#time-series-construction-note">time series</a></td>
<td> </td>
<td><span style="color: gray"># first observation time is 1:</span><br />
y = ts(rnorm(100))<br />
<br />
<span style="color: gray"># first observation time is 0:</span><br />
y2 = ts(rnorm(100), start=0)<br />
<br />
plot(y)</td>
<td><span style="color: gray"># first observation time is 0:</span><br />
y = pd.Series(randn(100))<br />
<br />
<span style="color: gray"># first observation time is 1:</span><br />
y2 = pd.Series(randn(100), index=range(1,101))<br />
<br />
y.plot()</td>
<td> </td>
</tr>
<tr>
<td><a name="monthly-time-series"></a><a href="#monthly-time-series-note">monthly time series</a></td>
<td> </td>
<td><span style="color: gray"># monthly observations 1993-1997:</span><br />
y = ts(rnorm(60), frequency=12, start=1993)<br />
<br />
<span style="color: gray"># monthly observations from Oct 1993:</span><br />
y2 = ts(rnorm(60), frequency=12, start=c(1993, 10))<br />
<br />
plot(y)</td>
<td>dt = pd.datetime(2013, 1, 1)<br />
idx = pd.date_range(dt, periods=60, freq=&#x27;M&#x27;)<br />
y = pd.Series(randn(60), index=idx)<br />
<br />
dt2 = pd.datetime(2013, 10, 1)<br />
idx2 = pd.date_range(dt2, periods=60, freq=&#x27;M&#x27;)<br />
y2 = pd.Series(randn(60), index=idx2)</td>
<td> </td>
</tr>
<tr>
<td><a name="time-series-lookup-time"></a><a href="#time-series-lookup-time-note">lookup by time</a></td>
<td> </td>
<td>start = tsp(y2)[1]<br />
end = tsp(y2)[2]<br />
freq = tsp(y2)[3]<br />
<br />
<span style="color: gray"># value for Jan 1994:</span><br />
y2[(1994 - start) * freq + 1]</td>
<td>y2[pd.datetime(2014, 1, 31)]</td>
<td> </td>
</tr>
<tr>
<td><a name="time-series-lookup-position"></a><a href="#time-series-lookup-position-note">lookup by position in series</a></td>
<td> </td>
<td>for (i in 1:length(y)) {<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>print(y[i])<br />
}</td>
<td>for i in range(0, len(y)):<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>y.ix[i]</td>
<td> </td>
</tr>
<tr>
<td><a name="aligned-arithmetic"></a><a href="#aligned-arithmetic-note">aligned arithmetic</a></td>
<td> </td>
<td>y = ts(rnorm(10), start=0)<br />
y2 = ts(rnorm(10), start=5)<br />
<br />
<span style="color: gray"># time series with 5 data points:</span><br />
y3 = y + y2</td>
<td>y = pd.Series(randn(10))<br />
y2 = pd.Series(randn(10), index=range(5, 15))<br />
<br />
<span style="color: gray"># time series with 15 data points; 10 of<br />
# which are NaN:</span><br />
# y3 = y + y2</td>
<td> </td>
</tr>
<tr>
<td><a name="lag-operator"></a><a href="#lag-operator-note">lag operator</a></td>
<td> </td>
<td>x = ts(rnorm(100))<br />
y = x + lag(x, 1)</td>
<td>x = pd.Series(randn(100))<br />
y = x + x.shift(-1)</td>
<td> </td>
</tr>
<tr>
<td><a name="lagged-difference"></a><a href="#lagged-difference-note">lagged difference</a><br />
<span style="white-space: pre-wrap;">&nbsp;</span></td>
<td> </td>
<td>delta = diff(y, lag=1)</td>
<td>delta = y.diff(1)</td>
<td> </td>
</tr>
<tr>
<td><a name="simple-moving-avg"></a><a href="#simple-moving-avg-note">simple moving average</a></td>
<td> </td>
<td>install.packages(&#x27;TTR&#x27;)<br />
library(&#x27;TTR&#x27;)<br />
<br />
ma = SMA(y, n=4)<br />
<br />
plot(y)<br />
lines(ma, col=&#x27;red&#x27;)</td>
<td>y = pd.Series(randn(50))<br />
ma = pd.rolling_mean(y, 4)<br />
<br />
plot(y, &#x27;k&#x27;, ma, &#x27;r&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="weighted-moving-avg"></a><a href="#weighted-moving-avg-note">weighted moving average</a></td>
<td> </td>
<td>install.packages(&#x27;TTR&#x27;)<br />
library(&#x27;TTR&#x27;)<br />
<br />
ma = WMA(y, n=4, wts=c(1, 2, 3, 4))<br />
<br />
plot(y)<br />
lines(ma, col=&#x27;red&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="exponential-smoothing"></a><a href="#exponential-smoothing-note">exponential smoothing</a></td>
<td> </td>
<td>x = rnorm(100)<br />
fit = HoltWinters(x, alpha=0.5, beta=F, gamma=F)<br />
<br />
values = fit$fitted<br />
plot(fit)</td>
<td>alpha = 0.5<br />
span = (2 / alpha) - 1<br />
fit = pd.ewma(y, span=span, adjust=False)<br />
<br />
fit.plot()</td>
<td> </td>
</tr>
<tr>
<td><a name="least-squares-exponential-smoothing"></a><a href="#least-squares-exponential-smoothing-note">exponential smoothing with best least squares fit</a></td>
<td> </td>
<td>x = rnorm(100)<br />
fit = HoltWinters(x, beta=F, gamma=F)<br />
<br />
alpha = fit$a<br />
plot(fit)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="decompose-seasonal-trend"></a><a href="#decompose-seasonal-trend-note">decompose into seasonal and trend</a></td>
<td> </td>
<td>raw = seq(1,100) + rnorm(100) + rep(seq(1,10), 10)<br />
y = ts(raw, frequency=10)<br />
<br />
<span style="color: gray"># additive model: t + s + r:</span><br />
yd = decompose(y)<br />
yd$trend<br />
yd$seasonal<br />
yd$random<br />
<br />
plot(yd)<br />
<br />
<span style="color: gray"># multiplicative model: t * s * r:</span><br />
yd2 = decompose(y, type=&quot;multiplicative&quot;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="correlogram"></a><a href="#correlogram-note">correlogram</a></td>
<td> </td>
<td>x = rnorm(100)<br />
x2 = append(x[4:100], x[1:3])<br />
<br />
acf(x, lag.max=20)<br />
acf(x + x2, lag.max=20)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>test for stationarity</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="arma"></a><a href="#arma-note">arma</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="arima"></a><a href="#arima-note">arima</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="automatic-arima"></a><a href="#arima-note">arima with automatic model selection</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="fast-fourier-transform"></a><a href="#fast-fourier-transform-note">fast fourier transform</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="fft"></a><a href="#fft-note">fft</a></td>
<td>x = 3 * sin(1:100) + sin(3 * (1:100)) + randn(1, 100)<br />
<br />
dft = fft(x)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="ifft"></a><a href="#ifft-note">inverse fft</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="fftshift"></a><a href="#fftshift-note">shift constant component to center</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="fft2"></a><a href="#fft2-note">two-dimensional fft</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="fftn"></a><a href="#fftn-note">n-dimensional fft</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="clustering"></a><a href="#clustering-note">clustering</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td>distance matrix</td>
<td>pts = [1 1; 1 2; 2 1; 2 3; 3 4; 4 4]<br />
<br />
<span style="color: gray">% value at (i, j) is distance between i-th<br />
% and j-th observation</span><br />
dm = squareform(pdist(pts, &#x27;euclidean&#x27;))</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>distance options</td>
<td><span style="color: gray">&#x27;euclidean&#x27;<br />
&#x27;seuclidian&#x27;<br />
&#x27;cityblock&#x27;<br />
&#x27;minkowski&#x27;<br />
&#x27;chebychev&#x27;<br />
&#x27;mahalanobis&#x27;<br />
&#x27;cosine&#x27;<br />
&#x27;correlation&#x27;<br />
&#x27;spearman&#x27;<br />
&#x27;hamming&#x27;<br />
&#x27;jaccard&#x27;</span></td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>hierarchical clusters</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>dendogram</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>silhouette plot</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>k-means</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="images"></a><a href="#images-note">images</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td>load from file</td>
<td>X = imread(&#x27;cat.jpg&#x27;);</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>display image</td>
<td>imshow(X)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>image info</td>
<td>whos X<br />
<br />
imfinfo(&#x27;cat.jpg&#x27;)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>write to file</td>
<td>imwrite(X, &#x27;cat2.jpg&#x27;)</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="sound"></a><a href="#sound-note">sound</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td>read from file</td>
<td>[y, fs] = audioread(&#x27;speech.flac&#x27;)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>record clip</td>
<td>recObj = audiorecorder<br />
<span style="color: gray">% record 5 seconds:</span><br />
recordblocking(recObj, 5)<br />
y = getaudiodata(recOjb);</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>write to file</td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>clip info</td>
<td>info = audioinfo(&#x27;speech.flac&#x27;)<br />
<br />
info.NumChannels<br />
info.SampleRate<br />
info.TotalSamples<br />
info.Duration</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td>play clip</td>
<td>sound(y, fs)</td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="bar-charts"></a><a href="#bar-charts-note">bar charts</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="vertical-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/vertical-bar-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/vertical-bar-chart.jpg" class="image" /><br />
<a href="#vertical-bar-chart-note">vertical bar chart</a></td>
<td>bar([7 3 8 5 5])<br />
set(gca, &#x27;XTick&#x27;, 1:5, <span style="white-space: pre-wrap;">...</span><br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>&#x27;XTickLabel&#x27;, {&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;})</td>
<td>cnts = c(7,3,8,5,5)<br />
names(cnts) = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)<br />
barplot(cnts)<br />
<br />
<span style="color: gray"># ggplot2:</span><br />
cnts = c(7,3,8,5,5)<br />
names = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)<br />
df = data.frame(names, cnts)<br />
qplot(names, data=df, geom=&quot;bar&quot;, weight=cnts)</td>
<td>cnts = [7,3,8,5,5]<br />
plt.bar(range(0,len(cnts)), cnts)</td>
<td> </td>
</tr>
<tr>
<td><a name="bar-chart-error-bars"></a><a href="#bar-chart-error-bars-note">bar chart with error bars</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="horizontal-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/horizontal-bar-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/horizontal-bar-chart.jpg" class="image" /><br />
<a href="#horizontal-bar-chart-note">horizontal bar chart</a></td>
<td>barh([7 3 8 5 5])</td>
<td>cnts = c(7,3,8,5,5)<br />
names(cnts) = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)<br />
barplot(cnts, horiz=T)</td>
<td>cnts = [7,3,8,5,5]<br />
plt.barh(range(0,len(cnts)), cnts)</td>
<td> </td>
</tr>
<tr>
<td><a name="grouped-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/grouped-bar-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/grouped-bar-chart.jpg" class="image" /><br />
<a href="#grouped-bar-chart-note">grouped bar chart</a></td>
<td>d = [7 1; 3 2; 8 1; 5 3; 5 1]<br />
bar(d)</td>
<td>data = matrix(c(7,1,3,2,8,1,5,3,5,1),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>nrow=2)<br />
labels = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)<br />
barplot(data, names.arg=labels, beside=TRUE)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="stacked-bar-chart"></a><img src="http://cdn.hyperpolyglot.org/images/stacked-bar-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/stacked-bar-chart.jpg" class="image" /><br />
<a href="#stacked-bar-chart-note">stacked bar chart</a></td>
<td>d = [7 1; 3 2; 8 1; 5 3; 5 1]<br />
bar(d, &#x27;stacked&#x27;)</td>
<td>data = matrix(c(7,1,3,2,8,1,5,3,5,1),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>nrow=2)<br />
labels = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)<br />
barplot(data, names.arg=labels)</td>
<td>a1 = [7,3,8,5,5]<br />
a2 = [1,2,1,3,1]<br />
plt.bar(range(0,5), a1, color=&#x27;r&#x27;)<br />
plt.bar(range(0,5), a2, color=&#x27;b&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="pie-chart"></a><img src="http://cdn.hyperpolyglot.org/images/pie-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/pie-chart.jpg" class="image" /><br />
<a href="#pie-chart-note">pie chart</a></td>
<td>labels = {&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;}<br />
pie([7 3 8 5 5], labels)</td>
<td>cnts = c(7,3,8,5,5)<br />
names(cnts) = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;)<br />
pie(cnts)</td>
<td>cnts = [7,3,8,5,5]<br />
labs = ['a','b','c','d','e']<br />
plt.pie(cnts, labels=labs)</td>
<td> </td>
</tr>
<tr>
<td><a name="histogram"></a><img src="http://cdn.hyperpolyglot.org/images/histogram.jpg" alt="http://cdn.hyperpolyglot.org/images/histogram.jpg" class="image" /><br />
<a href="#histogram-note">histogram</a></td>
<td>hist(randn(1, 100), 10)</td>
<td>hist(rnorm(100), breaks=10)<br />
<br />
hist(rnorm(100), breaks=seq(-3, 3, 0.5))<br />
<br />
<span style="color: gray"># ggplot2:</span><br />
x = rnorm(50)<br />
binwidth = (max(x) - min(x)) / 10<br />
qplot(x, geom=&quot;histogram&quot;, binwidth=binwidth)</td>
<td>plt.hist(sp.randn(100),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>bins=range(-5,5))</td>
<td> </td>
</tr>
<tr>
<td><a name="box-plot"></a><img src="http://cdn.hyperpolyglot.org/images/box-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/box-plot.jpg" class="image" /><br />
<a href="#box-plot-note">box plot</a></td>
<td>boxplot(randn(1, 100))</td>
<td>boxplot(rnorm(100))</td>
<td>plt.boxplot(sp.randn(100))</td>
<td> </td>
</tr>
<tr>
<td><a name="box-plots-side-by-side"></a><a href="#box-plots-side-by-side-note">box plots side-by-side</a></td>
<td>boxplot([randn(1, 100)<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>exprnd(1, 1, 100)<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>unifrnd(0, 1, 1, 100)]&#x27;)</td>
<td>boxplot(rnorm(100), rexp(100), runif(100))</td>
<td>plt.boxplot([sp.randn(100),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>np.random.uniform(size=100),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>np.random.exponential(size=100)])</td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="scatter-plots"></a><a href="#scatter-plots-note">scatter plots</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="strip-chart"></a><img src="http://cdn.hyperpolyglot.org/images/strip-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/strip-chart.jpg" class="image" /><br />
<a href="#strip-chart-note">strip chart</a></td>
<td>data = randn(1, 50)<br />
plot(data, zeros(size(data)), &#x27;o&#x27;)</td>
<td>stripchart(rnorm(50))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="strip-chart-jitter"></a><img src="http://cdn.hyperpolyglot.org/images/strip-chart-jitter.jpg" alt="http://cdn.hyperpolyglot.org/images/strip-chart-jitter.jpg" class="image" /><br />
<a href="#strip-chart-jitter-note">strip chart with jitter</a></td>
<td> </td>
<td>stripchart(floor(50 * runif(20)),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>method=&quot;jitter&quot;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="scatter-plot"></a><img src="http://cdn.hyperpolyglot.org/images/scatter-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/scatter-plot.jpg" class="image" /><br />
<a href="#scatter-plot-note">scatter plot</a></td>
<td>plot(randn(1,50),randn(1,50),&#x27;+&#x27;)</td>
<td>plot(rnorm(50), rnorm(50))</td>
<td>plt.scatter(sp.randn(50), sp.randn(50), marker=&#x27;x&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="additional-point-set"></a><img src="http://cdn.hyperpolyglot.org/images/additional-point-set.jpg" alt="http://cdn.hyperpolyglot.org/images/additional-point-set.jpg" class="image" /><br />
<a href="#additional-point-set-note">additional point set</a></td>
<td>plot(randn(20), randn(20), &#x27;.k&#x27;, randn(20), randn(20), &#x27;.r&#x27;)</td>
<td>plot(rnorm(20), rnorm(20))<br />
points(rnorm(20) + 1, rnorm(20) + 1,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>col=&#x27;red&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="point-types"></a><a href="#point-types-note">point types</a></td>
<td><span style="color: gray">&#x27;.&#x27;: point<br />
&#x27;o&#x27;: circle<br />
&#x27;x&#x27;: x-mark<br />
&#x27;+&#x27;: plus<br />
&#x27;*&#x27;: star<br />
&#x27;s&#x27;: square<br />
&#x27;d&#x27;: diamond<br />
&#x27;v&#x27;: triangle (down)<br />
&#x27;^&#x27;: triangle (up)<br />
&#x27;&lt;&#x27;: triangle (left)<br />
&#x27;&gt;&#x27;: traingle (right)<br />
&#x27;p&#x27;: pentagram<br />
&#x27;h&#x27;: hexagram</span></td>
<td><span style="color: gray"><em>Integer values for</em> pch <em>parameter:</em><br />
<br />
0: open square<br />
1: open circle<br />
2: open triangle, points up<br />
3: cross<br />
4: x<br />
5: open diamond<br />
6: open triangle, points down<br />
15: solid square<br />
16: solid circle<br />
17: solid triangle, points up<br />
18: solid diamond</span></td>
<td><span style="color: gray">marker <em>parameter takes these string values:</em></span><br />
<br />
<span style="color: gray">&#x27;.&#x27;: point<br />
&#x27;,&#x27;: pixel<br />
&#x27;o&#x27;: circle<br />
&#x27;v&#x27;: triangle_down<br />
&#x27;^&#x27;: triangle_up<br />
&#x27;&lt;&#x27;: triangle_left<br />
&#x27;&gt;&#x27;: triangle_right<br />
&#x27;1&#x27;: tri_down<br />
&#x27;2&#x27;: tri_up<br />
&#x27;3&#x27;: tri_left<br />
&#x27;4&#x27;: tri_right<br />
&#x27;8&#x27;: octagon<br />
&#x27;s&#x27;: square<br />
&#x27;p&#x27;: pentagon<br />
&#x27;*&#x27;: star<br />
&#x27;h&#x27;: hexagon1<br />
&#x27;H&#x27;: hexagon2<br />
&#x27;+&#x27;: plus<br />
&#x27;x&#x27;: x<br />
&#x27;D&#x27;: diamond<br />
&#x27;d&#x27;: thin_diamond<br />
&#x27;|&#x27;: vline<br />
&#x27;_&#x27;: hline</span></td>
<td> </td>
</tr>
<tr>
<td><a name="point-size"></a><a href="#point-size-note">point size</a></td>
<td> </td>
<td>plot(rnorm(50), rnorm(50), cex=2)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="scatter-plot-matrix"></a><img src="http://cdn.hyperpolyglot.org/images/scatter-plot-matrix.jpg" alt="http://cdn.hyperpolyglot.org/images/scatter-plot-matrix.jpg" class="image" /><br />
<a href="#scatter-plot-matrix-note">scatter plot matrix</a></td>
<td> </td>
<td>x = rnorm(20)<br />
y = rnorm(20)<br />
z = x + 3*y<br />
w = y + 0.1*rnorm(20)<br />
df = data.frame(x, y, z, w)<br />
<br />
pairs(df)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="scatter-plot-3d"></a><img src="http://cdn.hyperpolyglot.org/images/scatter-plot-3d.jpg" alt="http://cdn.hyperpolyglot.org/images/scatter-plot-3d.jpg" class="image" /><br />
<a href="#scatter-plot-3d-note">3d scatter plot</a></td>
<td> </td>
<td>install.packages(&#x27;scatterplot3d&#x27;)<br />
library(&#x27;scatterplot3d&#x27;)<br />
<br />
scatterplot3d(rnorm(50), rnorm(50),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>rnorm(50), type=&quot;h&quot;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="bubble-chart"></a><img src="http://cdn.hyperpolyglot.org/images/bubble-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/bubble-chart.jpg" class="image" /><br />
<a href="#bubble-chart-note">bubble chart</a></td>
<td> </td>
<td>install.packages(&#x27;ggplot2&#x27;)<br />
library(&#x27;ggplot2&#x27;)<br />
<br />
df = data.frame(x=rnorm(20),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>y=rnorm(20), z=rnorm(20))<br />
<br />
p = ggplot(df, aes(x=x, y=y, size=z))<br />
p + geom_point()</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="hexagonal-bins"></a><img src="http://cdn.hyperpolyglot.org/images/hexagonal-bins.jpg" alt="http://cdn.hyperpolyglot.org/images/hexagonal-bins.jpg" class="image" /><br />
<a href="#hexagonal-bins-note">hexagonal bins</a></td>
<td> </td>
<td>install.packages(&#x27;hexbin&#x27;)<br />
library(&#x27;hexbin&#x27;)<br />
<br />
plot(hexbin(rnorm(1000),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>rnorm(1000),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>xbins=12))</td>
<td>hexbin(randn(1000),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>randn(1000),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>gridsize=12)</td>
<td> </td>
</tr>
<tr>
<td><a name="linear-regression-line"></a><img src="http://cdn.hyperpolyglot.org/images/linear-regression-line.jpg" alt="http://cdn.hyperpolyglot.org/images/linear-regression-line.jpg" class="image" /><br />
<a href="#linear-regression-line-note">linear regression line</a></td>
<td> </td>
<td>x = 0:20<br />
y = 2 * x + rnorm(21) * 10<br />
<br />
fit = lm(y ~ x)<br />
<br />
plot(y)<br />
lines(x, fit$fitted.values, type=&#x27;l&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>col=&#x27;red&#x27;)</td>
<td>x = range(0,20)<br />
err = sp.randn(20)*10<br />
y = [2*i for i in x] + err<br />
<br />
A = np.vstack([x,np.ones(len(x))]).T<br />
m, c = np.linalg.lstsq(A, y)[0]<br />
<br />
plt.scatter(x, y)<br />
plt.plot(x, [m*i + c for i in x])</td>
<td> </td>
</tr>
<tr>
<td><a name="q-q-plot"></a><img src="http://cdn.hyperpolyglot.org/images/q-q-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/q-q-plot.jpg" class="image" /><br />
<a href="#q-q-plot-note">quantile-quantile plot</a></td>
<td> </td>
<td>qqplot(runif(50), rnorm(50))<br />
lines(c(-9,9), c(-9,9), col=&quot;red&quot;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="line-charts"></a><a href="#line-charts-note">line charts</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="polygonal-line-plot"></a><img src="http://cdn.hyperpolyglot.org/images/polygonal-line-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/polygonal-line-plot.jpg" class="image" /><br />
<a href="#polygonal-line-plot-note">polygonal line plot</a></td>
<td>plot(1:20,randn(1,20))</td>
<td>plot(1:20, rnorm(20), type=&quot;l&quot;)</td>
<td>plt.plot(range(0,20), sp.randn(20), &#x27;-&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="additional-line"></a><img src="http://cdn.hyperpolyglot.org/images/additional-line.jpg" alt="http://cdn.hyperpolyglot.org/images/additional-line.jpg" class="image" /><br />
<a href="#additional-line-note">additional line</a></td>
<td>plot(1:20, randn(1, 20),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>1:20, randn(1, 20))<br />
<br />
<span style="color: gray"><em>optional method:</em></span><br />
plot(1:20, randn(1, 20))<br />
hold on<br />
plot(1:20, randn(1, 20))</td>
<td>plot(1:20, rnorm(20), type=&quot;l&quot;)<br />
lines(1:20, rnorm(20), col=&quot;red&quot;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="line-types"></a><a href="#line-types-note">line types</a></td>
<td><span style="color: gray"><em>Optional 3rd argument to plot:</em><br />
<br />
&#x27;-&#x27;: solid<br />
&#x27;:&#x27;: dotted<br />
&#x27;-.&#x27;: dashdot<br />
&#x27;--&#x27;: dashed</span>--</td>
<td><span style="color: gray"><em>Integer or string values for</em> lty <em>parameter:</em><br />
<br />
0: &#x27;blank&#x27;<br />
1: &#x27;solid&#x27; (default)<br />
2: &#x27;dashed&#x27;<br />
3: &#x27;dotted&#x27;<br />
4: &#x27;dotdash&#x27;<br />
5: &#x27;longdash&#x27;<br />
6: &#x27;twodash&#x27;</span></td>
<td><span style="color: gray"><em>Optional 3rd argument to plot:</em></span><br />
<br />
<span style="color: gray">&#x27;-&#x27;: solid line<br />
<span style="white-space: pre-wrap;">&#x27;--&#x27;</span>: dashed line<br />
&#x27;-.&#x27;: dash-dot line<br />
&#x27;:&#x27;: dotted line<br />
&#x27;.&#x27;: point<br />
&#x27;,&#x27;: pixel<br />
&#x27;o&#x27;: circle<br />
&#x27;v&#x27;: triangle_down<br />
&#x27;^&#x27;: triangle_up<br />
&#x27;&lt;&#x27;: triangle_left<br />
&#x27;&gt;&#x27;: triangle_right<br />
&#x27;1&#x27;: tri_down<br />
&#x27;2&#x27;: tri_up<br />
&#x27;3&#x27;: tri_left<br />
&#x27;4&#x27;: tri_right<br />
&#x27;s&#x27;: square<br />
&#x27;p&#x27;: pentagon<br />
&#x27;*&#x27;: star<br />
&#x27;h&#x27;: hexagon1<br />
&#x27;H&#x27;: hexagon2<br />
&#x27;+&#x27;: plus<br />
&#x27;x&#x27;: x<br />
&#x27;D&#x27;: diamond<br />
&#x27;d&#x27;: thin_diamond<br />
&#x27;|&#x27;: vline<br />
&#x27;_&#x27;: hline</span></td>
<td> </td>
</tr>
<tr>
<td><a name="line-thickness"></a><a href="#line-thickness-note">line thickness</a></td>
<td> </td>
<td>plot(1:20, rnorm(20), type=&quot;l&quot;, lwd=5)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="function-plot"></a><img src="http://cdn.hyperpolyglot.org/images/function-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/function-plot.jpg" class="image" /><br />
<a href="#function-plot-note">function plot</a></td>
<td>fplot(@sin, [-4 4])</td>
<td>x = seq(-4, 4, .01)<br />
plot(sin(x), type=&quot;l&quot;)</td>
<td>x = [i * .01 for i in range(-400, 400)]<br />
plt.plot(x, sin(x), &#x27;-&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="area-chart"></a><img src="http://cdn.hyperpolyglot.org/images/area-chart.jpg" width="75px" alt="http://cdn.hyperpolyglot.org/images/area-chart.jpg" class="image" /><br />
<a href="#area-chart-note">stacked area chart</a></td>
<td> </td>
<td>install.packages(&#x27;ggplot2&#x27;)<br />
library(&#x27;ggplot2&#x27;)<br />
<br />
x = rep(0:4, each=3)<br />
y = round(5 * runif(15))<br />
letter = rep(LETTERS[1:3], 5)<br />
df = data.frame(x, y, letter)<br />
<br />
p = ggplot(df, aes(x=x, y=y,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>group=letter,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>fill=letter))<br />
p + geom_area(position=&#x27;stack&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="overlapping-area-chart"></a><img src="http://cdn.hyperpolyglot.org/images/overlapping-area-chart.jpg" alt="http://cdn.hyperpolyglot.org/images/overlapping-area-chart.jpg" class="image" /><br />
<a href="#overlapping-area-chart-note">overlapping area chart</a></td>
<td> </td>
<td>install.packages(&#x27;ggplot2&#x27;)<br />
library(&#x27;ggplot2&#x27;)<br />
<br />
x = rep(0:4, each=3)<br />
y = round(5 * runif(15))<br />
letter = rep(LETTERS[1:3], 5)<br />
df = data.frame(x, y, letter)<br />
alpha = rep(I(2/10), each=15)<br />
<br />
p = ggplot(df, aes(x=x, ymin=0, ymax=y,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>group=letter, fill=letter,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>alpha=alpha))<br />
p + geom_ribbon()</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="surface-charts"></a><a href="#surface-charts-note">surface charts</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="contour-plot"></a><img src="http://cdn.hyperpolyglot.org/images/contour-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/contour-plot.jpg" class="image" /><br />
<a href="#contour-plot-note">contour plot</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="heat-map"></a><img src="http://cdn.hyperpolyglot.org/images/heat-map.jpg" alt="http://cdn.hyperpolyglot.org/images/heat-map.jpg" class="image" /><br />
<a href="#heat-map-note">heat map</a></td>
<td>i = ones(100, 1) * (1:100)<br />
j = (1:100)&#x27; * ones(1, 100)<br />
data = sin(.2 * i) .* sin(.2 * j)<br />
colormap(gray)<br />
imagesc(data)</td>
<td>m = matrix(0, 100, 100)<br />
for (i in 2:100) {<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>for (j in 2:100) { <br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>m[i,j] = (m[i-1,j] + m[i,j-1])/2 +<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span><span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>runif(1) - 0.5<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>}<br />
}<br />
<br />
filled.contour(1:100, 1:100, m)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="shaded-surface-plot"></a><img src="http://cdn.hyperpolyglot.org/images/shaded-surface-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/shaded-surface-plot.jpg" class="image" /><br />
<a href="#shaded-surface-plot-note">shaded surface plot</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="light-source"></a><a href="#light-source-note">light source</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="mesh-surface-plot"></a><img src="http://cdn.hyperpolyglot.org/images/mesh-surface-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/mesh-surface-plot.jpg" class="image" /><br />
<a href="#mesh-surface-plot-note">mesh surface plot</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="view-point"></a><a href="#view-point-note">view point</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="vector-field-plot"></a><img src="http://cdn.hyperpolyglot.org/images/vector-field-plot.jpg" alt="http://cdn.hyperpolyglot.org/images/vector-field-plot.jpg" class="image" /><br />
<a href="#vector-field-plot-note">vector field plot</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<th colspan="5"><a name="chart-options"></a><a href="#chart-options-note">chart options</a></th>
</tr>
<tr>
<th></th>
<th><a href="#matlab">matlab</a></th>
<th><a href="#r">r</a></th>
<th><a href="#numpy">numpy</a></th>
<th><a href="#julia">julia</a></th>
</tr>
<tr>
<td><a name="chart-title"></a><a href="#chart-title-note">chart title</a></td>
<td>bar([7 3 8 5 5])<br />
title(&#x27;bar chart example&#x27;)</td>
<td><span style="color: gray"><em>all chart functions except for</em> stem <em>accept a</em> main <em>parameter:</em></span><br />
boxplot(rnorm(100),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>main=&quot;boxplot example&quot;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>sub=&quot;to illustrate options&quot;)</td>
<td>plt.boxplot(sp.randn(100))<br />
plt.title(&#x27;boxplot example&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="axis-labels"></a><a href="#axis-labels-note">axis labels</a></td>
<td>plot( 1:20, (1:20) .** 2)<br />
xlabel(&#x27;x&#x27;)<br />
ylabel(&#x27;x squared&#x27;)</td>
<td>plot(1:20, (1:20)^2,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>xlab=&quot;x&quot;, ylab=&quot;x squared&quot;)</td>
<td>x = range(0, 20)<br />
plt.plot(x, [i * i for i in x], &#x27;-&#x27;)<br />
plt.xlabel(&#x27;x&#x27;)<br />
plt.ylabel(&#x27;x squared&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="legend"></a><img src="http://cdn.hyperpolyglot.org/images/legend.jpg" alt="http://cdn.hyperpolyglot.org/images/legend.jpg" class="image" /><br />
<a href="#legend-note">legend</a></td>
<td> </td>
<td>x = (1:20)<br />
y = x + rnorm(20)<br />
y2 = x - 2 + rnorm(20)<br />
<br />
plot(x, y, type=&quot;l&quot;, col=&quot;black&quot;)<br />
lines(x, y2, type=&quot;l&quot;, col=&quot;red&quot;)<br />
legend(&#x27;topleft&#x27;, c(&#x27;first&#x27;, &#x27;second&#x27;),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>lty=c(1,1), lwd=c(2.5, 2.5),<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>col=c(&#x27;black&#x27;, &#x27;red&#x27;))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="colors"></a><a href="#colors-note">colors</a></td>
<td><span style="color: gray"><em>Use color letters by themselves for colored lines. Use &#x27;.r&#x27; for red dots.</em><br />
<br />
&#x27;b&#x27;: blue<br />
&#x27;g&#x27;: green<br />
&#x27;r&#x27;: red<br />
&#x27;c&#x27;: cyan<br />
&#x27;m&#x27;: magenta<br />
&#x27;y&#x27;: yellow<br />
&#x27;k&#x27;: black<br />
&#x27;w&#x27;: white</span></td>
<td><span style="color: gray"># Use the col parameter to specify the color of<br />
# points and lines.<br />
#<br />
# The colors() function returns a list of<br />
# recognized names for colors.</span><br />
<br />
plot(rnorm(10), col=&#x27;red&#x27;)<br />
plot(rnorm(10), col=&#x27;#FF0000&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="axis-limits"></a><a href="#axis-limits-note">axis limits</a></td>
<td>plot( 1:20, (1:20) .** 2)<br />
<span style="color: gray">% [xmin, xmax, ymin, ymax]:</span><br />
axis([1 20 -200 500])</td>
<td>plot(1:20, (1:20)^2,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>xlim=c(0, 20), ylim=c(-200,500))</td>
<td>x = range(0, 20)<br />
plt.plot(x, [i * i for i in x], &#x27;-&#x27;)<br />
plt.xlim([0, 20])<br />
plt.ylim([-200, 500])</td>
<td> </td>
</tr>
<tr>
<td><a name="logarithmic-y-axis"></a><a href="#logarithmic-y-axis-note">logarithmic y-axis</a></td>
<td>semilogy(x, x .** 2,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x, x .** 3,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x, x .** 4,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>x, x .** 5)</td>
<td>x = 0:20<br />
plot(x, x^2, log=&quot;y&quot;,type=&quot;l&quot;)<br />
lines(x, x^3, col=&quot;blue&quot;)<br />
lines(x, x^4, col=&quot;green&quot;)<br />
lines(x, x^5, col=&quot;red&quot;)</td>
<td>x = range(0, 20)<br />
<br />
for i in [2,3,4,5]:<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>y.append([j**i for j in x])<br />
<br />
for i in [0,1,2,3]:<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>semilogy(x, y[i])</td>
<td> </td>
</tr>
<tr>
<td><a name="superimposed-plots"></a><a href="#superimposed-plots-note">superimposed plots with different y-axis scales</a></td>
<td> </td>
<td>x &lt;- 1:10<br />
y &lt;- rnorm(10)<br />
z &lt;- rnorm(10) * 1000<br />
par(mar = c(5, 4, 4, 4) + 0.3)<br />
plot(x, y, type=&#x27;l&#x27;)<br />
par(new=T)<br />
plot(x, z, col=&#x27;red&#x27;, type=&#x27;l&#x27;, axes=F,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>xlab=&#x27;&#x27;, ylab=&#x27;&#x27;)<br />
axis(side=4, col=&#x27;red&#x27;, col.axis=&#x27;red&#x27;,<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>at=pretty(range(z)))<br />
mtext(&#x27;z&#x27;, side=4, line=3, col=&#x27;red&#x27;)</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="aspect-ratio"></a><a href="#aspect-ratio-note">aspect ratio</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="ticks"></a><a href="#ticks-note">ticks</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="grid-lines"></a><a href="#grid-lines-note">grid lines</a></td>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="subplot-grid"></a><img src="http://cdn.hyperpolyglot.org/images/subplot-grid.jpg" alt="http://cdn.hyperpolyglot.org/images/subplot-grid.jpg" class="image" /><br />
<a href="#subplot-grid-note">grid of subplots</a></td>
<td><span style="color: gray">% 3rd arg refers to the subplot;<br />
% subplots are numbered in row-major order.</span><br />
for i = 1:4<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>subplot(2, 2, i), hist(randn(50))<br />
end</td>
<td>for (i in split.screen(c(2, 2))) {<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>screen(n=i)<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>hist(rnorm(100))<br />
}</td>
<td>for i in [1, 2, 3, 4]:<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>plt.subplot(2, 2, i)<br />
<span style="white-space: pre-wrap;">&nbsp;&nbsp;</span>plt.hist(sp.randn(100), bins=range(-5,5))</td>
<td> </td>
</tr>
<tr>
<td><a name="new-plot-window"></a><a href="#new-plot-window-note">open new plot window</a></td>
<td>open new plot<br />
figure<br />
open new plot</td>
<td>hist(rnorm(100))<br />
dev.new()<br />
hist(rnorm(100))</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="close-plot-windows"></a><a href="#close-plot-windows-note">close all plot windows</a></td>
<td>close all</td>
<td>graphics.off()</td>
<td> </td>
<td> </td>
</tr>
<tr>
<td><a name="save-plot-as-png"></a><a href="#save-plot-as-png-note">save plot as png</a></td>
<td>f = figure<br />
hist(randn(100))<br />
print(f, &#x27;-dpng&#x27;, &#x27;histogram.png&#x27;)</td>
<td>png(&#x27;hist.png&#x27;)<br />
hist(rnorm(100))<br />
dev.off()</td>
<td>y = randn(50)<br />
plot(y)<br />
savefig(&#x27;line-plot.png&#x27;)</td>
<td> </td>
</tr>
<tr>
<td><a name="save-plot-as-svg"></a><a href="#save-plot-as-svg-note">save plot as svg</a></td>
<td> </td>
<td>svg(&#x27;hist.svg&#x27;)<br />
hist(rnorm(100))<br />
dev.off()</td>
<td> </td>
<td> </td>
</tr>
<tr>
<th></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________________</span></span></th>
<th><span style="color: #efefef"><span style="white-space: pre-wrap;">__________________________________________________</span></span></th>
</tr>
</table>
<p><a name="tables-note"></a></p>
<h1 id="toc0"><span><a href="#tables">Tables</a></span></h1>
<p>Tables are a data type which correspond to the tables of relational databases. In R this data type is called a <em>data frame</em>. The Python library Pandas provides a table data type called <em>DataFrame</em>.</p>
<p>A table is an array of tuples, each of the same length and type. If the type of the first element of the first type is integer, then all the tuples in the table must have first elements which are integers. The type of the tuples corresponds to the schema of a relational database table.</p>
<p>A table can also be</p>
<p>Pandas types: Series(), DataFrame(), Index()</p>
<p><a name="construct-from-column-arrays-note"></a></p>
<h2 id="toc1"><span><a href="#construct-from-column-arrays">construct from column arrays</a></span></h2>
<p>How to construct a data frame from a set of arrays representing the columns.</p>
<p><strong>octave:</strong></p>
<p>Octave does not have the <tt>table</tt> data type.</p>
<p><a name="table-size-note"></a></p>
<h2 id="toc2"><span><a href="#table-size">size</a></span></h2>
<p>How to get the number of columns and number of rows in a table.</p>
<p><a name="construct-from-row-tuples-note"></a></p>
<h2 id="toc3"><span><a href="#construct-from-row-tuples">construct from row tuples</a></span></h2>
<p><a name="column-names-as-array-note"></a></p>
<h2 id="toc4"><span><a href="#column-names-as-array">column names as array</a></span></h2>
<p>How to show the names of the columns.</p>
<p><a name="access-column-as-array-note"></a></p>
<h2 id="toc5"><span><a href="#access-column-as-array">access column as array</a></span></h2>
<p>How to access a column in a data frame.</p>
<p><a name="access-row-as-tuple-note"></a></p>
<h2 id="toc6"><span><a href="#access-row-as-tuple">access row as tuple</a></span></h2>
<p>How to access a row in a data frame.</p>
<p><strong>r:</strong></p>
<p><em>people[1, ]</em> returns the 1st row from the data frame <em>people</em> as a new data frame with one row. This can be converted to a list using the function <em>as.list</em>. There is often no need because lists and one row data frames have nearly the same behavior.</p>
<p><a name="access-datum-note"></a></p>
<h2 id="toc7"><span><a href="#access-datum">access datum</a></span></h2>
<p>How to access a single datum in a data frame; i.e. the value in a column of a single row.</p>
<p><a name="order-rows-by-column-note"></a></p>
<h2 id="toc8"><span><a href="#order-rows-by-column">order rows by column</a></span></h2>
<p>How to sort the rows in a data frame according to the values in a specified column.</p>
<p><a name="order-rows-by-multiple-columns-note"></a></p>
<h2 id="toc9"><span><a href="#order-rows-by-multiple-columns">order rows by multiple columns</a></span></h2>
<p><a name="order-rows-descending-order-note"></a></p>
<h2 id="toc10"><span><a href="#order-rows-descending-order">order rows in descending order</a></span></h2>
<p>How to sort the rows in descending order according to the values in a specified column.</p>
<p><a name="limit-rows-note"></a></p>
<h2 id="toc11"><span><a href="#limit-rows">limit rows</a></span></h2>
<p>How to select the first <em>n</em> rows according to some ordering.</p>
<p><a name="offset-rows-note"></a></p>
<h2 id="toc12"><span><a href="#offset-rows">offset rows</a></span></h2>
<p>How to select rows starting at offset <em>n</em> according to some ordering.</p>
<p><a name="attach-columns-note"></a></p>
<h2 id="toc13"><span><a href="#attach-columns">attach columns</a></span></h2>
<p>How to make column name a variable in the current scope which refers to the column as an array.</p>
<p><strong>r:</strong></p>
<p>Each column of the data frame is copies into a variable named after the column containing the column as a vector. Modifying the data in the variable does not alter the original data frame.</p>
<p><a name="detach-columns-note"></a></p>
<h2 id="toc14"><span><a href="#detach-columns">detach columns</a></span></h2>
<p>How to remove attached column names from the current scope.</p>
<p><a name="spreadsheet-editor-note"></a></p>
<h2 id="toc15"><span><a href="#spreadsheet-editor">spreadsheet editor</a></span></h2>
<p>How to view and edit the data frame in a spreadsheet.</p>
<p><a name="import-export-note"></a></p>
<h1 id="toc16"><span><a href="#import-export">Import and Export</a></span></h1>
<p><a name="import-tab-delimited-note"></a></p>
<h2 id="toc17"><span><a href="#import-tab-delimited">import tab delimited file</a></span></h2>
<p>Load a data frame from a tab delimited file.</p>
<p><strong>r:</strong></p>
<p>By default strings are converted to factors. In older versions of R, this could reduce the amount of memory required to load the data frame; this is no longer true in newer versions.</p>
<p><a name="import-csv-note"></a></p>
<h2 id="toc18"><span><a href="#import-csv">import comma-separated values file</a></span></h2>
<p>Load a data frame from a CSV file.</p>
<p><a name="column-separator-note"></a></p>
<h2 id="toc19"><span><a href="#column-separator">set column separator</a></span></h2>
<p>How to set the column separator when importing a delimited file.</p>
<p><a name="quote-char-note"></a></p>
<h2 id="toc20"><span><a href="#quote-char">set quote character</a></span></h2>
<p>How to change the quote character. Quoting is used when strings contain the column separator or the line terminator.</p>
<p><a name="no-header-note"></a></p>
<h2 id="toc21"><span><a href="#no-header">import file w/o header</a></span></h2>
<p>How to import a file that lacks a header.</p>
<p><a name="set-column-names-note"></a></p>
<h2 id="toc22"><span><a href="#set-column-names">set column names</a></span></h2>
<p>How to set the column names.</p>
<p><a name="set-column-types-note"></a></p>
<h2 id="toc23"><span><a href="#set-column-types">set column types</a></span></h2>
<p>How to indicate the type of the columns.</p>
<p><strong>r:</strong></p>
<p>If the column types are not set or if the type is set to NA or NULL, then the type will be set to logical, integer, numeric, complex, or factor.</p>
<p><a name="recognize-null-values-note"></a></p>
<h2 id="toc24"><span><a href="#recognize-null-values">recognize null values</a></span></h2>
<p>Specify the input values which should be converted to null values.</p>
<p><a name="unequal-row-length-note"></a></p>
<h2 id="toc25"><span><a href="#unequal-row-length">unequal row length behavior</a></span></h2>
<p>What happen when a row of input has less than or more than the expected number of columns.</p>
<p><a name="skip-comment-lines-note"></a></p>
<h2 id="toc26"><span><a href="#skip-comment-lines">skip comment lines</a></span></h2>
<p>How to skip comment lines.</p>
<p><a name="skip-rows-note"></a></p>
<h2 id="toc27"><span><a href="#skip-rows">skip rows</a></span></h2>
<p><a name="max-rows-to-read-note"></a></p>
<h2 id="toc28"><span><a href="#max-rows-to-read">maximum rows to read</a></span></h2>
<p><a name="index-column-note"></a></p>
<h2 id="toc29"><span><a href="#index-column">index column</a></span></h2>
<p><a name="export-tab-delimited-note"></a></p>
<h2 id="toc30"><span><a href="#export-tab-delimited">export tab delimited file</a></span></h2>
<p><a name="export-csv-note"></a></p>
<h2 id="toc31"><span><a href="#export-csv">export comma-separated values file</a></span></h2>
<p>Save a data frame to a CSV file.</p>
<p><strong>r:</strong></p>
<p>If row.names is not set to F, the initial column will be the row number as a string starting from &quot;1&quot;.</p>
<p><a name="relational-algebra-note"></a></p>
<h1 id="toc32"><span><a href="#relational-algebra">Relational Algebra</a></span></h1>
<p><a name="data-frame-map-note"></a></p>
<h2 id="toc33"><span><a href="#data-frame-map">map data frame</a></span></h2>
<p>How to apply a mapping transformation to the rows of a data set.</p>
<p><a name="data-set-filter-note"></a></p>
<h2 id="toc34"><span><a href="#data-set-filter">filter data set</a></span></h2>
<p>How to select the rows of a data set that satisfy a predicate.</p>
<p><a name="aggregation-note"></a></p>
<h1 id="toc35"><span><a href="#aggregation">Aggregation</a></span></h1>
<p><a name="vectors-note"></a></p>
<h1 id="toc36"><span><a href="#vectors">Vectors</a></span></h1>
<p>A vector is a one dimensional array which supports these operations:</p>
<ul>
<li>addition on vectors of the same length</li>
<li>scalar multiplication</li>
<li>a dot product</li>
<li>a norm</li>
</ul>
<p>The languages in this reference sheet provide the above operations for all one dimensional arrays which contain numeric values.</p>
<p><a name="vector-literal"></a></p>
<h2 id="toc37"><span>vector literal</span></h2>
<p><a name="vector-element-wise"></a></p>
<h2 id="toc38"><span>element-wise arithmetic operators</span></h2>
<p><a name="vector-scalar"></a></p>
<h2 id="toc39"><span>scalar multiplication</span></h2>
<p><a name="vector-dot"></a></p>
<h2 id="toc40"><span>dot product</span></h2>
<p><a name="vector-cross"></a></p>
<h2 id="toc41"><span>cross product</span></h2>
<p><a name="vector-norms"></a></p>
<h2 id="toc42"><span>norms</span></h2>
<p><strong>matlab:</strong></p>
<p>The <em>norm</em> function returns the p-norm, where the second argument is <em>p</em>. If no second argument is provided, the 2-norm is returned.</p>
<p><a name="matrices-note"></a></p>
<h1 id="toc43"><span><a href="#matrices">Matrices</a></span></h1>
<p><a name="matrix-literal-constructor-note"></a></p>
<h2 id="toc44"><span><a href="#matrix-literal-constructor">literal or constructor</a></span></h2>
<p>Literal syntax or constructor for creating a matrix.</p>
<p>The elements of a matrix must be specified in a linear order. If the elements of each row of the matrix are adjacent to other elements of the same row in the linear order we say the order is <em>row-major</em>. If the elements of each column are adjacent to other elements of the same column we say the order is <em>column-major</em>.</p>
<p><strong>matlab:</strong></p>
<p>Square brackets are used for matrix literals. Semicolons are used to separate rows, and commas separate row elements. Optionally, newlines can be used to separate rows and whitespace to separate row elements.</p>
<p><strong>r:</strong></p>
<p>Matrices are created by passing a vector containing all of the elements, as well as the number of rows and columns, to the <em>matrix</em> constructor.</p>
<p>If there are not enough elements in the data vector, the values will be recycled. If there are too many extra values will be ignored. However, the number of elements in the data vector must be a factor or a multiple of the number of elements in the final matrix or an error results.</p>
<p>When consuming the elements in the data vector, R will normally fill by column. To change this behavior pass a <em>byrow=T</em> argument to the <em>matrix</em> constructor:</p>
<div class="code">
<pre>
<code>A = matrix(c(1,2,3,4),nrow=2,byrow=T)</code>
</pre></div>
<p><a name="constant-matrices-note"></a></p>
<h2 id="toc45"><span><a href="#constant-matrices">constant matrices</a></span></h2>
<p>How to create a matrices with zeros for entries or with ones for entries.</p>
<p><a name="diagonal-matrices-note"></a></p>
<h2 id="toc46"><span><a href="#diagonal-matrices">diagonal matrices</a></span></h2>
<p>How to create diagonal matrices including the identity matrix.</p>
<p>A matrix is diagonal if and only if <tt>a<sub>ij</sub> = 0</tt> for all <tt>i ≠ j</tt>.</p>
<p><a name="matrix-dim-note"></a></p>
<h2 id="toc47"><span><a href="#matrix-dim">dimensions</a></span></h2>
<p>How to get the dimensions of a matrix.</p>
<p><a name="matrix-access"></a></p>
<h2 id="toc48"><span>element access</span></h2>
<p>How to access an element of a matrix. All languages described here follow the convention from mathematics of specifying the row index before the column index.</p>
<p><strong>matlab:</strong></p>
<p>Rows and columns are indexed from one.</p>
<p><strong>r:</strong></p>
<p>Rows and columns are indexed from one.</p>
<p><a name="matrix-row-access"></a></p>
<h2 id="toc49"><span>row access</span></h2>
<p>How to access a row.</p>
<p><a name="matrix-column-access"></a></p>
<h2 id="toc50"><span>column access</span></h2>
<p>How to access a column.</p>
<p><a name="submatrix-access"></a></p>
<h2 id="toc51"><span>submatrix access</span></h2>
<p>How to access a submatrix.</p>
<p><a name="matrix-scalar-multiplication"></a></p>
<h2 id="toc52"><span>scalar multiplication</span></h2>
<p>How to multiply a matrix by a scalar.</p>
<p><a name="matrix-element-wise-operators"></a></p>
<h2 id="toc53"><span>element-wise operators</span></h2>
<p>Operators which act on two identically sized matrices element by element. Note that element-wise multiplication of two matrices is used less frequently in mathematics than matrix multiplication.</p>
<div class="code">
<pre>
<code>from numpy import array
matrix(array(A) * array(B))
matrix(array(A) / array(B))</code>
</pre></div>
<p><a name="matrix-multiplication"></a></p>
<h2 id="toc54"><span>multiplication</span></h2>
<p>How to multiply matrices. Matrix multiplication should not be confused with element-wise multiplication of matrices. Matrix multiplication in non-commutative and only requires that the number of columns of the matrix on the left match the number of rows of the matrix. Element-wise multiplication, by contrast, is commutative and requires that the dimensions of the two matrices be equal.</p>
<p><a name="kronecker-product"></a></p>
<h2 id="toc55"><span>kronecker product</span></h2>
<p>The <a href="http://en.wikipedia.org/wiki/Kronecker_product">Kronecker product</a> is a non-commutative operation defined on any two matrices. If A is m x n and B is p x q, then the Kronecker product is a matrix with dimensions mp x nq.</p>
<p><a name="matrix-comparison"></a></p>
<h2 id="toc56"><span>comparison</span></h2>
<p>How to test two matrices for equality.</p>
<p><strong>matlab:</strong></p>
<p>== and != perform entry-wise comparison. The result of using either operator on two matrices is a matrix of boolean values.</p>
<p>~= is a synonym for !=.</p>
<p><strong>r:</strong></p>
<p>== and != perform entry-wise comparison. The result of using either operator on two matrices is a matrix of boolean values.</p>
<p><a name="matrix-norms"></a></p>
<h2 id="toc57"><span>norms</span></h2>
<p>How to compute the 1-norm, the 2-norm, the infinity norm, and the frobenius norm.</p>
<p><strong>matlab:</strong></p>
<p><em>norm(A)</em> is the same as <em>norm(A,2)</em>.</p>
<p><a name="sparse-matrices-note"></a></p>
<h1 id="toc58"><span><a href="#sparse-matrices">Sparse Matrices</a></span></h1>
<p><a name="sparse-matrix-construction-note"></a></p>
<h2 id="toc59"><span><a href="#sparse-matrix-construction">sparse matrix construction</a></span></h2>
<p>How to construct a sparse matrix using coordinate format.</p>
<p>Coordinate format specifies a matrix with three arrays: the row indices, the the column indices, and the values.</p>
<p><a name="sparse-matrix-decomposition-note"></a></p>
<h2 id="toc60"><span><a href="#sparse-matrix-decomposition">sparse matrix decomposition</a></span></h2>
<p><a name="sparse-identity-matrix-note"></a></p>
<h2 id="toc61"><span><a href="#sparse-identity-matrix">sparse identity matrix</a></span></h2>
<p><a name="dense-matrix-to-sparse-matrix-note"></a></p>
<h2 id="toc62"><span><a href="#dense-matrix-to-sparse-matrix">dense matrix to sparse matrix</a></span></h2>
<p><a name="sparse-matrix-storage-note"></a></p>
<h2 id="toc63"><span><a href="#sparse-matrix-storage">sparse matrix storage</a></span></h2>
<p><a name="optimization-note"></a></p>
<h1 id="toc64"><span><a href="#optimization">Optimization</a></span></h1>
<p>In an optimization problem one seeks the smallest or largest value assumed by an <em>objective function</em>. The inputs to the objective function are the <em>decision variables</em>. A set of equations or inequalities, the <em>constraints</em>, can be used to restrict the decision variables to a <em>feasible region</em>.</p>
<p>If the feasible region is empty, the problem is said to be <em>infeasible</em>. If a minimization problem does not have a lower bound on the feasible region, or if a maximization problem does not have an upper bound on the feasible region, the problem is said to be <em>unbounded</em>.</p>
<p>An optimization problem is <em>linear</em> if both its objective function and its constraints are linear. A constraint is linear if it can be written in the form <em>∑ aᵢ xᵢ ≤ b</em>, <em>∑ aᵢ xᵢ ≥ b</em>, or <em>∑ aᵢ xᵢ = b</em>, where <em>xᵢ</em> are the decision variables.</p>
<p>An <em>integer linear program</em> is a linear optimization problem where the decision variables are constrained to assume integer values. Polynomial time algorithms exist for solving linear programs when the decision variables are real-valued, but solving integer linear programs is NP-hard. A <em>mixed integer linear program</em> has a mix of integer and real-valued decision variables. A special case of an integer linear program is a <em>binary linear program</em> where the decision variables assume the values 0 or 1.</p>
<p><a name="linear-min-note"></a></p>
<h2 id="toc65"><span><a href="#linear-min">linear minimization</a></span></h2>
<p>An example of a linear minimization problem.</p>
<p><a name="decision-var-vec-note"></a></p>
<h2 id="toc66"><span><a href="#decision-var-vec">decision variable vector</a></span></h2>
<p>How to declare a vector of decision variables.</p>
<p><a name="linear-max-note"></a></p>
<h2 id="toc67"><span><a href="#linear-max">linear maximization</a></span></h2>
<p>An example of a linear maximization problem.</p>
<p><a name="var-declaration-constraint-note"></a></p>
<h2 id="toc68"><span><a href="#var-declaration-constraint">constraint in variable declaration</a></span></h2>
<p>How to include a constraint on a decision variable in its declaration.</p>
<p><a name="unbounded-behavior-note"></a></p>
<h2 id="toc69"><span><a href="#unbounded-behavior">unbounded behavior</a></span></h2>
<p>What happens when attempting to solve an unbounded optimization problem.</p>
<p><a name="infeasible-behavior-note"></a></p>
<h2 id="toc70"><span><a href="#infeasible-behavior">infeasible behavior</a></span></h2>
<p>What happens when attempting to solve an infeasible optimization problem.</p>
<p><a name="int-decision-var-note"></a></p>
<h2 id="toc71"><span><a href="#int-decision-var">integer decision variable</a></span></h2>
<p>How to declare a decision variable to be integer valued.</p>
<p><strong>matlab:</strong></p>
<p>The solvers which ship with CVX do not support integer programming.</p>
<p><a name="binary-decision-var-note"></a></p>
<h2 id="toc72"><span><a href="#binary-decision-var">binary decision variable</a></span></h2>
<p>How to declare a decision variable to only take the values 0 or 1.</p>
<p><a name="polynomials-note"></a></p>
<h1 id="toc73"><span><a href="#polynomials">Polynomials</a></span></h1>
<h2 id="toc74"><span>exact polynomial fit</span></h2>
<p><a name="cubic-spline-note"></a></p>
<h2 id="toc75"><span><a href="#cubic-spline">cubic spline</a></span></h2>
<p>How to connect the dots of a data set with a line which has a continuous 2nd derivative.</p>
<p><a name="descriptive-statistics-note"></a></p>
<h1 id="toc76"><span><a href="#descriptive-statistics">Descriptive Statistics</a></span></h1>
<p>A statistic is a single number which summarizes a population of data. The most familiar example is the mean or average. Statistics defined for discrete populations can often be meaningfully extended to continuous distributions by replacing summations with integration.</p>
<p>An important class of statistics are the nth moments. The nth moment [[$ \mu'_n $]] of a population of //k// values //x,,i,,// with mean //<span style="white-space: pre-wrap;">&mu;</span>// is:</p>
<span class="equation-number">(1)</span>
<div class="math-equation" id="equation-1">$$ \begin{align} \mu&#x27;_n = \sum_{i=1}^k x_i^n \end{align} $$</div>
<p>The nth central moment //<span style="white-space: pre-wrap;">&mu;</span><sub>n</sub>// of the same population is:</p>
<span class="equation-number">(2)</span>
<div class="math-equation" id="equation-2">$$ \begin{align} \mu_n = \sum_{i=1}^k (x_i - \mu)^n \end{align} $$</div>
<p><a name="first-moment-stats-note"></a></p>
<h2 id="toc77"><span><a href="#first-moment-stats">first moment statistics</a></span></h2>
<p>The sum and the mean.</p>
<p>The mean is the first moment. It is one definition of the center of the population. The median and the mode are also used to define the center. In most populations they will be close to but not identical to the mean.</p>
<p><a name="second-moment-stats-note"></a></p>
<h2 id="toc78"><span><a href="#second-moment-stats">second moment statistics</a></span></h2>
<p>The variance and the standard deviation. The variance is the second central moment. It is a measure of the spread or width of the population.</p>
<p>The standard deviation is the square root of the variance. It is also a measurement of population spread. The standard deviation has the same units of measurement as the data in the population.</p>
<p><a name="second-moment-stats-sample-note"></a></p>
<h2 id="toc79"><span><a href="#second-moment-stats-sample">second moment statistics for samples</a></span></h2>
<p>The sample variance and sample standard deviation.</p>
<p><a name="skewness-note"></a></p>
<h2 id="toc80"><span><a href="#skewness">skewness</a></span></h2>
<p>The skewness of a population.</p>
<p>The skewness measures the asymmetricality of the population. The skewness will be negative, positive, or zero when the population is more spread out on the left, more spread out on the right, or similarly spread out on both sides, respectively.</p>
<p>The skewness can be calculated from the third moment and the standard deviation:</p>
<span class="equation-number">(3)</span>
<div class="math-equation" id="equation-3">$$ \begin{align} \gamma_1 = E\Big[\Big(\frac{x - \mu}{\sigma}\Big)^3\Big] = \frac{\mu_3}{\sigma^3} \end{align} $$</div>
<p>When estimating the population skewness from a sample a correction factor is often used, yielding the sample skewness:</p>
<span class="equation-number">(4)</span>
<div class="math-equation" id="equation-4">$$ \begin{align} \frac{(n(n-1))^{\frac{1}{2}}}{n-2} \gamma_1 \end{align} $$</div>
<p><strong>octave and matlab:</strong></p>
<p>Octave uses the sample standard deviation to compute skewness. This behavior is different from Matlab and should possibly be regarded as a bug.</p>
<p>Matlab, but not Octave, will take a flag as a second parameter. When set to zero Matlab returns the sample skewness:</p>
<div class="code">
<pre>
<code>skewness(x, 0)</code>
</pre></div>
<p><strong>numpy:</strong></p>
<p>Set the named parameter <tt>bias</tt> to <tt>False</tt> to get the sample skewness:</p>
<div class="code">
<pre>
<code>stats.skew(x, bias=False)</code>
</pre></div>
<p><a name="kurtosis-note"></a></p>
<h2 id="toc81"><span><a href="#kurtosis">kurtosis</a></span></h2>
<p>The kurtosis of a population.</p>
<p>The formula for kurtosis is:</p>
<span class="equation-number">(5)</span>
<div class="math-equation" id="equation-5">$$ \begin{align} \gamma_2 = \frac{\mu_4}{\sigma^4} - 3 \end{align} $$</div>
<p>When kurtosis is negative the sides of a distribution tend to be more convex than when the kurtosis is is positive. A negative kurtosis distribution tends to have a wide, flat peak and narrow tails. Such a distribution is called platykurtic. A positive kurtosis distribution tends to have a narrow, sharp peak and long tails. Such a distribution is called leptokurtic.</p>
<p>The fourth standardized moment is</p>
<span class="equation-number">(6)</span>
<div class="math-equation" id="equation-6">$$ \begin{align} \beta_2 = \frac{\mu_4}{\sigma^4} \end{align} $$</div>
<p>The fourth standardized moment is sometimes taken as the definition of kurtosis in older literature. The reason the modern definition is preferred is because it assigns the normal distribution a kurtosis of zero.</p>
<p><strong>matlab:</strong></p>
<p>Octave uses the sample standard deviation when computing kurtosis. This should probably be regarded as a bug.</p>
<p><strong>r:</strong></p>
<p>R uses the older fourth standardized moment definition of kurtosis.</p>
<p><a name="nth-moment-note"></a></p>
<h2 id="toc82"><span><a href="#nth-moment">nth moment and nth central moment</a></span></h2>
<p>How to compute the nth moment (also called the nth absolute moment) and the nth central moment for arbitrary <em>n</em>.</p>
<p><a name="mode-note"></a></p>
<h2 id="toc83"><span><a href="#mode">mode</a></span></h2>
<p>The mode is the most common value in the sample.</p>
<p>The mode is a measure of central tendency like the mean and the median. A problem with the mean is that it can produce values not found in the data. For example the mean number of persons in an American household was 2.6 in 2009.</p>
<p>The mode might not be unique. If there are two modes the sample is said to be bimodal, and in general if there is more than one mode the sample is said to be multimodal.</p>
<p><a name="quantile-stats-note"></a></p>
<h2 id="toc84"><span><a href="#quantile-stats">quantile statistics</a></span></h2>
<p>If the data is sorted from smallest to largest, the <em>minimum</em> is the first value, the <em>median</em> is the middle value, and the <em>maximum</em> is the last value. If there are an even number of data points, the median is the average of the two middle points. The median divides the population into two halves.</p>
<p>When the population is divided into four parts the division markers are called the first, second, and third <em>quartiles</em>. The <em>interquartile range</em> (IQR) is the difference between the 3rd and 1st quartiles.</p>
<p>When the population is divided into ten parts the division markers are called <em>deciles</em>.</p>
<p>When the population is divided into a hundred parts the division markers are called <em>percentiles</em>.</p>
<p>If the population is divided into <em>n</em> parts the markers are called the 1st, 2nd, ..., (n-1)th n-<em>quantiles</em>.</p>
<p><a name="bivariate-stats-note"></a></p>
<h2 id="toc85"><span><a href="#bivariate-stats">bivariate statistics</a></span></h2>
<p>The correlation and the covariance.</p>
<p>The correlation is a number from -1 to 1. It is a measure of the linearity of the data, with values of -1 and 1 representing indicating a perfectly linear relationship. When the correlation is positive the quantities tend to increase together and when the correlation is negative one quantity will tend to increase as the other decreases.</p>
<p>A variable can be completely dependent on another and yet the two variables can have zero correlation. This happens for Y = X<sup>2</sup> where uniform X on the interval [-1, 1]. <a href="http://en.wikipedia.org/wiki/Anscombe's_quartet">Anscombe's quartet</a> gives four examples of data sets each with the same fairly high correlation 0.816 and yet which show significant qualitative differences when plotted.</p>
<p>The covariance is defined by</p>
<span class="equation-number">(7)</span>
<div class="math-equation" id="equation-7">$$ \begin{align} E[X -\mu_X)(Y- \mu_Y)] \end{align} $$</div>
<p>The correlation is the normalized version of the covariance. It is defined by</p>
<span class="equation-number">(8)</span>
<div class="math-equation" id="equation-8">$$ \begin{align} \frac{E[X -\mu_X)(Y- \mu_Y)]}{\sigma_X \sigma_Y} \end{align} $$</div>
<p><a name="correlation-matrix-note"></a></p>
<h2 id="toc86"><span><a href="#correlation-matrix">correlation matrix</a></span></h2>
<p><a name="freq-table-note"></a></p>
<h2 id="toc87"><span><a href="#freq-table">data set to frequency table</a></span></h2>
<p>How to compute the frequency table for a data set. A frequency table counts how often each value occurs in the data set.</p>
<p><strong>r:</strong></p>
<p>The <tt>table</tt> function returns an object of type <tt>table</tt>.</p>
<p><a name="invert-freq-table-note"></a></p>
<h2 id="toc88"><span><a href="#invert-freq-table">frequency table to data set</a></span></h2>
<p>How to convert a frequency table back into the original data set.</p>
<p>The order of the original data set is not preserved.</p>
<p><a name="bin-note"></a></p>
<h2 id="toc89"><span><a href="#bin">bin</a></span></h2>
<p>How to bin a data set. The result is a frequency table where each frequency represents the number of samples from the data set for an interval.</p>
<p><strong>r:</strong></p>
<p>The <tt>cut</tt> function returns a <tt>factor</tt>.</p>
<p>A <tt>labels</tt> parameter can be provided with a vector argument to assign the bins names. Otherwise bin names are constructed from the breaks using &quot;[0.0,1.0)&quot; style notation.</p>
<p>The <tt>hist</tt> function can be used to bin a data set:</p>
<div class="code">
<pre>
<code>x = c(1.1, 3.7, 8.9, 1.2, 1.9, 4.1)
hist(x, breaks=c(0, 3, 6, 9), plot=FALSE)</code>
</pre></div>
<p><tt>hist</tt> returns an object of type <tt>histogram</tt>. The counts are in the <tt>$counts</tt> attribute.</p>
<p><a name="distribution-note"></a></p>
<h1 id="toc90"><span><a href="#distributions">Distributions</a></span></h1>
<p>A distribution density function <em>f(x)</em> is a non-negative function which, when integrated over its entire domain is equal to one. The distributions described in this sheet have as their domain the real numbers. The support of a distribution is the part of the domain on which the density function is non-zero.</p>
<p>A distribution density function can be used to describe the values one is likely to see when drawing an example from a population. Values in areas where the density function is large are more likely than values in areas where the density function is small. Values where there density function is zero do not occur. Thus it can be useful to plot the density function.</p>
<p>To derive probabilities from a density function one must integrate or use the associated cumulative density function</p>
<span class="equation-number">(9)</span>
<div class="math-equation" id="equation-9">$$ \begin{align} F(x) = \int_{-\infty}^x f(t) dt \end{align} $$</div>
<p>which gives the probability of seeing a value less than or equal to //x//. As probabilities are non-negative and no greater than one, //F// is a function from (-<span style="white-space: pre-wrap;">&infin;</span>, <span style="white-space: pre-wrap;">&infin;</span>) to [0,1]. The inverse of F is called the inverse cumulative distribution function or the quantile function for the distribution.</p>
<p>For each distribution statistical software will generally provide four functions: the density, the cumulative distribution, the quantile, and a function which returns random numbers in frequencies that match the distribution. If the software does not provide a random number generating function for the distribution, the quantile function can be composed with the built-in random number generator that most languages have as long as it returns uniformly distributed floats from the interval [0, 1].</p>
<table class="wiki-content-table">
<tr>
<td>density<br />
probability density<br />
probability mass</td>
<td>cumulative density<br />
cumulative distribution<br />
distribution</td>
<td>inverse cumulative density<br />
inverse cumulative distribution<br />
quantile<br />
percentile<br />
percent point</td>
<td>random variate</td>
</tr>
</table>
<p>Discrete distributions such as the binomial and the poisson do not have density functions in the normal sense. Instead they have probability mass functions which assign probabilities which sum up to one to the integers. In R warnings will be given if non integer values are provided to the mass functions <tt>dbinom</tt> and <tt>dpoiss</tt>.</p>
<p>The cumulative distribution function of a discrete distribution can still be defined on the reals. Such a function is constant except at the integers where it may have jump discontinuities.</p>
<p>Most well known distributions are in fact parametrized families of distributions. <a href="/distributions">This table</a> lists some of them with their parameters and properties.</p>
<p>The information entropy of a continuous distribution with density <em>f(x)</em> is defined as:</p>
<span class="equation-number">(10)</span>
<div class="math-equation" id="equation-10">$$ \begin{align} -\int_\mathbb{R} f(x) \; \log(f(x)) \; dx \end{align} $$</div>
<p>In Bayesian analysis the distribution with the greatest entropy, subject to the known facts about the distribution, is called the maximum entropy probability distribution. It is considered the best distribution for modeling the current state of knowledge.</p>
<p><a name="binomial-note"></a></p>
<h2 id="toc91"><span><a href="#binomial">binomial</a></span></h2>
<p>The probability mass, cumulative distribution, quantile, and random number generating functions for the binomial distribution.</p>
<p>The binomial distribution is a discrete distribution. It models the number of successful trails when <em>n</em> is the number of trials and <em>p</em> is the chance of success for each trial. An example is the number of heads when flipping a coin 100 times. If the coin is fair then <em>p</em> is 0.50.</p>
<p><strong>numpy:</strong></p>
<p>Random numbers in a binomial distribution can also be generated with:</p>
<div class="code">
<pre>
<code>np.random.binomial(n, p)</code>
</pre></div>
<p><a name="poisson-note"></a></p>
<h2 id="toc92"><span><a href="#poisson">poisson</a></span></h2>
<p>The probability mass, cumulative distribution, quantile, and random number generating functions for the Poisson distribution.</p>
<p>The Poisson distribution is a discrete distribution. It is described by a parameter <em>lam</em> which is the mean value for the distribution. The Poisson distribution is used to model events which happen at a specified average rate and independently of each other. Under these circumstances the time between successive events will be described by an exponential distribution and the events are said to be described by a poisson process.</p>
<p><strong>numpy:</strong></p>
<p>Random numbers in a Poisson distribution can also be generated with:</p>
<div class="code">
<pre>
<code>np.random.poisson(lam, size=1)</code>
</pre></div>
<p><a name="normal-note"></a></p>
<h2 id="toc93"><span><a href="#normal">normal</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for the normal distribution.</p>
<p>The parameters are the mean <span style="white-space: pre-wrap;">&mu;</span> and the standard deviation <span style="white-space: pre-wrap;">&sigma;</span>. The standard normal distribution has <span style="white-space: pre-wrap;">&mu;</span> of 0 and <span style="white-space: pre-wrap;">&sigma;</span> of 1.</p>
<p>The normal distribution is the maximum entropy distribution for a given mean and variance. According to the central limit theorem, if {X,,1,,, ..., X,,n,,} are any independent and identically distributed random variables with mean <span style="white-space: pre-wrap;">&mu;</span> and variance <span style="white-space: pre-wrap;">&sigma;</span>^^2^^, then S,,n,, := <span style="white-space: pre-wrap;">&Sigma;</span> X,,i,, / n converges to a normal distribution with mean <span style="white-space: pre-wrap;">&mu;</span> and variance <span style="white-space: pre-wrap;">&sigma;</span><sup>2</sup>/n.</p>
<p><strong>numpy:</strong></p>
<p>Random numbers in a normal distribution can also be generated with:</p>
<div class="code">
<pre>
<code>np.random.randn()</code>
</pre></div>
<p><a name="gamma-note"></a></p>
<h2 id="toc94"><span><a href="#gamma">gamma</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for the gamma distribution.</p>
<p>The parameter //k// is called the shape parameter and <span style="white-space: pre-wrap;">&theta;</span> is called the scale parameter. The rate of the distribution is <span style="white-space: pre-wrap;">&beta;</span> = 1/<span style="white-space: pre-wrap;">&theta;</span>.</p>
<p>If X,,i,, are //n// independent random variables with <span style="white-space: pre-wrap;">&Gamma;</span>(k,,i,,, <span style="white-space: pre-wrap;">&theta;</span>) distribution, then <span style="white-space: pre-wrap;">&Sigma;</span> X,,i,, has distribution <span style="white-space: pre-wrap;">&Gamma;</span>(<span style="white-space: pre-wrap;">&Sigma;</span> k,,i,,, <span style="white-space: pre-wrap;">&theta;</span>).</p>
<p>If X has <span style="white-space: pre-wrap;">&Gamma;</span>(k, <span style="white-space: pre-wrap;">&theta;</span>) distribution, then <span style="white-space: pre-wrap;">&alpha;</span>X has <span style="white-space: pre-wrap;">&Gamma;</span>(k, <span style="white-space: pre-wrap;">&alpha;</span><span style="white-space: pre-wrap;">&theta;</span>) distribution.</p>
<p><a name="exponential-note"></a></p>
<h2 id="toc95"><span><a href="#exponential">exponential</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for the exponential distribution.</p>
<p><a name="chi-squared-note"></a></p>
<h2 id="toc96"><span><a href="#chi-squared">chi-squared</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for the chi-squared distribution.</p>
<p><a name="beta-note"></a></p>
<h2 id="toc97"><span><a href="#beta">beta</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for the beta distribution.</p>
<p><a name="uniform-note"></a></p>
<h2 id="toc98"><span><a href="#uniform">uniform</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for the uniform distribution.</p>
<p>The uniform distribution is described by the parameters <em>a</em> and <em>b</em> which delimit the interval on which the density function is nonzero.</p>
<p>The uniform distribution the is maximum entropy probability distribution with support <em>[a, b]</em>.</p>
<p>Consider the uniform distribution on <em>[0, b]</em>. Suppose that we take <em>k</em> samples from it, and <em>m</em> is the largest of the samples. The minimum variance unbiased estimator for <em>b</em> is</p>
<span class="equation-number">(11)</span>
<div class="math-equation" id="equation-11">$$ \begin{align} \frac{k+1}{k}m \end{align} $$</div>
<p><strong>octave, r, numpy:</strong></p>
<p><em>a</em> and <em>b</em> are optional parameters and default to 0 and 1 respectively.</p>
<p><a name="students-t-note"></a></p>
<h2 id="toc99"><span><a href="#students-t">Student's t</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for Student&#x27;s t distribution.</p>
<p><a name="snedecors-f-note"></a></p>
<h2 id="toc100"><span><a href="#snedecors-f">Snedecor's F</a></span></h2>
<p>The probability density, cumulative distribution, quantile, and random number generating functions for Snedecor&#x27;s F distribution.</p>
<p><a name="empirical-density-func-note"></a></p>
<h2 id="toc101"><span><a href="#empirical-density-func">empirical density function</a></span></h2>
<p>How to construct a density function from a sample.</p>
<p><a name="empirical-cumulative-distribution-note"></a></p>
<h2 id="toc102"><span><a href="#empirical-cumulative-distribution">empirical cumulative distribution</a></span></h2>
<p><a name="empirical-quantile-func-note"></a></p>
<h2 id="toc103"><span><a href="#empirical-quantile-func">empirical quantile function</a></span></h2>
<p><a name="linear-regression-note"></a></p>
<h1 id="toc104"><span><a href="#linear-regression">Linear Regression</a></span></h1>
<p><a name="simple-linear-regression-note"></a></p>
<h2 id="toc105"><span><a href="#simple-linear-regression">simple linear regression</a></span></h2>
<p>How to get the slope <em>a</em> and intercept <em>b</em> for a line which best approximates the data. How to get the residuals.</p>
<p>If there are more than two data points, then the system is overdetermined and in general there is no solution for the slope and the intercept. Linear regression looks for line that fits the points as best as possible. The least squares solution is the line that minimizes the sum of the square of the distances of the points from the line.</p>
<p>The residuals are the difference between the actual values of <em>y</em> and the calculated values using <em>ax + b</em>. The norm of the residuals can be used as a measure of the goodness of fit.</p>
<p><a name="linear-regression-no-intercept-note"></a></p>
<h2 id="toc106"><span><a href="#linear-regression-no-intercept">no intercept</a></span></h2>
<p><a name="multiple-linear-regression-note"></a></p>
<h2 id="toc107"><span><a href="#multiple-linear-regression">multiple linear regression</a></span></h2>
<p><a name="linear-regression-interaction-note"></a></p>
<h2 id="toc108"><span><a href="#linear-regression-interaction">interaction</a></span></h2>
<p><a name="logistic-regression-note"></a></p>
<h2 id="toc109"><span><a href="#logistic-regression">logistic regression</a></span></h2>
<p><a name="statistical-tests-note"></a></p>
<h1 id="toc110"><span><a href="#statistical-tests">Statistical Tests</a></span></h1>
<p>A selection of statistical tests. For each test the null hypothesis of the test is stated in the left column.</p>
<p>In a null hypothesis test one considers the <em>p-value</em>, which is the chance of getting data which is as or more extreme than the observed data if the null hypothesis is true. The null hypothesis is usually a supposition that the data is drawn from a distribution with certain parameters.</p>
<p>The extremeness of the data is determined by comparing the expected value of a parameter according to the null hypothesis to the estimated value from the data. Usually the parameter is a mean or variance. In a <em>one-tailed test</em> the p-value is the chance the difference is greater than the observed amount; in a <em>two-tailed test</em> the p-value is the chance the absolute value of the difference is greater than the observed amount.</p>
<p>Octave and MATLAB have different names for the statistical test functions. The sheet shows the Octave functions; the corresponding MATLAB functions are:</p>
<table class="wiki-content-table">
<tr>
<th>octave</th>
<th>matlab</th>
</tr>
<tr>
<td>wilcoxon_test</td>
<td>ranksum</td>
</tr>
<tr>
<td>kruskal_wallis_test</td>
<td>kruskalwallis</td>
</tr>
<tr>
<td>kolmogorov_smirnov_test</td>
<td>kstest</td>
</tr>
<tr>
<td>kolmogorov_smirnov_test_2</td>
<td>kstest2</td>
</tr>
<tr>
<td>t_test</td>
<td>ttest</td>
</tr>
<tr>
<td>t_test_2</td>
<td>ttest2</td>
</tr>
</table>
<p><a name="wilcoxon-note"></a></p>
<h2 id="toc111"><span><a href="#wilcoxon">wilcoxon signed-rank test</a></span></h2>
<p><strong>matlab</strong></p>
<p><tt>wilcoxon_test()</tt> is an Octave function. The MATLAB function is <tt>ranksum()</tt>.</p>
<p><a name="kruskal-note"></a></p>
<h2 id="toc112"><span><a href="#kruskal">kruskal-wallis rank sum test</a></span></h2>
<p><a name="kolmogorov-smirnov-test-note"></a></p>
<h2 id="toc113"><span><a href="#kolmogorov-smirnov-test">kolmogorov-smirnov test</a></span></h2>
<p>Test whether two samples are drawn from the same distribution.</p>
<p><strong>matlab:</strong></p>
<p><tt>kolmogorov_smirnov_test_2()</tt> and <tt>kolmogorov_smirnov_test()</tt> are Octave functions. The corresponding MATLAB functions are <tt>kstest2()</tt> and <tt>kstest()</tt>.</p>
<p><tt>kolmogorov_smirnov_test()</tt> is a one sample test; it tests whether a sample is drawn from one of the standard continuous distributions. A one sample KS test gives a repeatable p-value; generating a sample and using a two sample KS test does not.</p>
<div class="code">
<pre>
<code>x = randn(100, 1)

% null hypothesis is true:
kolmogorov_smirnov_test(x, &quot;norm&quot;, 0, 1)

% alternative hypothesis is true:
kolmogorov_smirnov_test(x, &quot;unif&quot;, -0.5, 0.5)</code>
</pre></div>
<p><strong>r:</strong></p>
<p><a name="one-sample-t-test-note"></a></p>
<h2 id="toc114"><span><a href="#one-sample-t-test">one-sample t-test</a></span></h2>
<p><a name="independent-two-sample-t-test-note"></a></p>
<h2 id="toc115"><span><a href="#independent-two-sample-t-test">independent two-sample t-test</a></span></h2>
<p>Test whether two normal variables have same mean.</p>
<p><strong>r:</strong></p>
<p>If the normal variables are known to have the same variance, the variance can be pooled to estimate standard error:</p>
<div class="code">
<pre>
<code>t.test(x, y, var.equal=T)</code>
</pre></div>
<p>If the variance cannot be pooled, then Welch&#x27;s t-test is used. This uses a lower (often non-integral) degrees-of-freedom value, which in turn results in a higher p-value.</p>
<p><a name="one-sample-binomial-test-note"></a></p>
<h2 id="toc116"><span><a href="#one-sample-binomial-test">one-sample binomial test</a></span></h2>
<p><a name="two-sample-binomial-test-note"></a></p>
<h2 id="toc117"><span><a href="#two-sample-binomial-test">two-sample binomial test</a></span></h2>
<p><a name="chi-squared-test-note"></a></p>
<h2 id="toc118"><span><a href="#chi-squared-test">chi-squared test</a></span></h2>
<p><a name="poisson-test-note"></a></p>
<h2 id="toc119"><span><a href="#poisson-test">poisson test</a></span></h2>
<p><a name="f-test-note"></a></p>
<h2 id="toc120"><span><a href="#f-test">F test</a></span></h2>
<p><a name="pearson-product-moment-test-note"></a></p>
<h2 id="toc121"><span><a href="#pearson-product-moment-test">pearson product moment test</a></span></h2>
<p><a name="shapiro-wilk-test-note"></a></p>
<h2 id="toc122"><span><a href="#shapiro-wilk-test">shapiro-wilk test</a></span></h2>
<p><a name="bartletts-test-note"></a></p>
<h2 id="toc123"><span><a href="#bartletts-test">bartlett's test</a></span></h2>
<p>A test whether variables are drawn from normal distributions with the same variance.</p>
<p><a name="levene-test-note"></a></p>
<h2 id="toc124"><span><a href="#levene-test">levene's test</a></span></h2>
<p>A test whether variables are drawn from distributions with the same variance.</p>
<p><a name="one-way-anova-note"></a></p>
<h2 id="toc125"><span><a href="#one-way-anova">one-way anova</a></span></h2>
<p><a name="time-series-note"></a></p>
<h1 id="toc126"><span><a href="#time-series">Time Series</a></span></h1>
<p>A <em>time series</em> is a sequence of data points collected repeatedly on a uniform time interval.</p>
<p>A time series can be represented by a dictionary which maps timestamps to the type of the data points. A more efficient implementation exploits the fact that the time interval is uniform and stores the data points in an array. To recover the timestamps of the data points, the timestamp of the first data point and the length of the time interval are also stored.</p>
<p><a name="time-series-construction-note"></a></p>
<h2 id="toc127"><span><a href="#time-series-construction">time series</a></span></h2>
<p>How to create a time series from an array.</p>
<p><a name="monthly-time-series-note"></a></p>
<h2 id="toc128"><span><a href="#monthly-time-series">monthly time series</a></span></h2>
<p>How to create a time series with one data point per month.</p>
<p><a name="time-series-lookup-time-note"></a></p>
<h2 id="toc129"><span><a href="#time-series-lookup-time">lookup by time</a></span></h2>
<p>How to get to a data point in a time series by when the data point was collected.</p>
<p><a name="time-series-lookup-position-note"></a></p>
<h2 id="toc130"><span><a href="#time-series-lookup-position">lookup by position in series</a></span></h2>
<p>How to get a data point in a time series by its ordinal position.</p>
<p><a name="aligned-arithmetic-note"></a></p>
<h2 id="toc131"><span><a href="#aligned-arithmetic">aligned arithmetic</a></span></h2>
<p><a name="lagged-difference-note"></a></p>
<h2 id="toc132"><span><a href="#lagged-difference">lagged difference</a></span></h2>
<p><a name="simple-moving-avg-note"></a></p>
<h2 id="toc133"><span><a href="#simple-moving-avg">simple moving average</a></span></h2>
<p><a name="weighted-moving-avg-note"></a></p>
<h2 id="toc134"><span><a href="#weighted-moving-avg">weighted moving average</a></span></h2>
<p><a name="exponential-smoothing-note"></a></p>
<h2 id="toc135"><span><a href="#exponential-smoothing">exponential smoothing</a></span></h2>
<p><a name="decompose-seasonal-trend-note"></a></p>
<h2 id="toc136"><span><a href="#decompose-seasonal-trend">decompose into seasonal and trend</a></span></h2>
<p><a name="correlogram-note"></a></p>
<h2 id="toc137"><span><a href="#correlogram">correlogram</a></span></h2>
<p><a name="arima-note"></a></p>
<h2 id="toc138"><span><a href="#arima">arima</a></span></h2>
<p><a name="fast-fourier-transform-note"></a></p>
<h1 id="toc139"><span><a href="#fast-fourier-transform">Fast Fourier Transform</a></span></h1>
<p><a name="fft-note"></a></p>
<h2 id="toc140"><span>[[# fft fft]</span></h2>
<p><a name="ifft-note"></a></p>
<h2 id="toc141"><span><a href="#ifft">inverse fft</a></span></h2>
<p><a name="fftshift-note"></a></p>
<h2 id="toc142"><span><a href="#fftshift">shift constant component to center</a></span></h2>
<p><a name="fft2-note"></a></p>
<h2 id="toc143"><span><a href="#fft2">two-dimensional fft</a></span></h2>
<p><a name="fftn-note"></a></p>
<h2 id="toc144"><span><a href="#fftn">n-dimensional fft</a></span></h2>
<p><a name="clustering-note"></a></p>
<h1 id="toc145"><span><a href="#clustering">Clustering</a></span></h1>
<p><a name="images-note"></a></p>
<h1 id="toc146"><span><a href="#images">Images</a></span></h1>
<p><a name="sound-note"></a></p>
<h1 id="toc147"><span><a href="#sound">Sound</a></span></h1>
<p><a name="bar-charts-note"></a></p>
<h1 id="toc148"><span><a href="#bar-charts">Bar Charts</a></span></h1>
<p><a name="vertical-bar-chart-note"></a></p>
<h2 id="toc149"><span><a href="#vertical-bar-chart">vertical bar chart</a></span></h2>
<p>A chart in which numerical values are represented by horizontal bars. The bars are aligned at the bottom.</p>
<p><a name="horizontal-bar-chart-note"></a></p>
<h2 id="toc150"><span><a href="#horizontal-bar-chart">horizontal bar chart</a></span></h2>
<p>A bar chart with horizontal bars which are aligned on the left.</p>
<p><a name="grouped-bar-chart-note"></a></p>
<h2 id="toc151"><span><a href="#grouped-bar-chart">grouped bar chart</a></span></h2>
<p>Optionally data sets with a common set of labels can be charted with a grouped bar chart which clusters the bars for each label. The grouped bar chart makes it easier to perform comparisons between labels for each data set.</p>
<p><a name="stacked-bar-chart-note"></a></p>
<h2 id="toc152"><span><a href="#stacked-bar-chart">stacked bar chart</a></span></h2>
<p>Two or more data sets with a common set of labels can be charted with a stacked bar chart. This makes the sum of the data sets for each label readily apparent.</p>
<p><a name="pie-chart-note"></a></p>
<h2 id="toc153"><span><a href="#pie-chart">pie chart</a></span></h2>
<p>A pie chart displays values using the areas of circular sectors or equivalently the lengths of the arcs of those sectors.</p>
<p>A pie chart implies that the values are percentages of a whole.</p>
<p><a name="histogram-note"></a></p>
<h2 id="toc154"><span><a href="#histogram">histogram</a></span></h2>
<p>A histogram is a bar chart where each bar represents a range of values that the data points can fall in. The data is tabulated to find out how often data points fall in each of the bins and in the final chart the length of the bars corresponds to the frequency.</p>
<p>A common method for choosing the number of bins using the number of data points is Sturges&#x27; formula:</p>
<span class="equation-number">(12)</span>
<div class="math-equation" id="equation-12">$$ \begin{align} \lceil \log_2{x} + 1 \rceil \end{align} $$</div>
<p><a name="box-plot-note"></a></p>
<h2 id="toc155"><span><a href="#box-plot">box plot</a></span></h2>
<p>Also called a box-and-whisker plot.</p>
<p>The box shows the locations of the 1st quartile, median, and 3rd quartile. These are the same as the 25th percentile, 50th percentile, and 75th percentile.</p>
<p>The whiskers are sometimes used to show the maximum and minimum values of the data set. Outliers are sometimes shown explicitly with dots, in which case all remaining data points occur inside the whiskers.</p>
<p><strong>r:</strong></p>
<p>How to create a box plot with <tt>ggplot2</tt>:</p>
<div class="code">
<pre>
<code>qplot(x=&quot;rnorm&quot;, y=rnorm(50), geom=&quot;boxplot&quot;)

qplot(x=c(&quot;rnorm&quot;, &quot;rexp&quot;, &quot;runif&quot;), y=c(rnorm(50), rexp(50), runif(50)), geom=&quot;boxplot&quot;)</code>
</pre></div>
<p><a name="scatter-plots-note"></a></p>
<h1 id="toc156"><span><a href="#scatter-plots">Scatter Plots</a></span></h1>
<p><a name="scatter-plot-note"></a></p>
<h2 id="toc157"><span><a href="#scatter-plot">scatter plot</a></span></h2>
<p>A scatter plot can be used to determine if two variables are correlated.</p>
<p><strong>r:</strong></p>
<p>How to make a scatter plot with <tt>ggplot</tt>:</p>
<div class="code">
<pre>
<code>x = rnorm(50)
y = rnorm(50)
p = ggplot(data.frame(x, y), aes(x, y))
p = p + layer(geom=&quot;point&quot;)
p</code>
</pre></div>
<p><a name="additional-point-set-note"></a></p>
<h2 id="toc158"><span><a href="#additional-point-set">additional point set</a></span></h2>
<p><a name="point-types-note"></a></p>
<h2 id="toc159"><span><a href="#point-types">point types</a></span></h2>
<p><a name="hexagonal-bins-note"></a></p>
<h2 id="toc160"><span><a href="#hexagonal-bins">hexagonal bins</a></span></h2>
<p>A hexagonal binning is the two-dimensional analog of a histogram. The number of data points in each hexagon is tabulated, and then color or grayscale is used to show the frequency.</p>
<p>A hexagonal binning is superior to a scatter-plot when the number of data points is high because most scatter-plot software doesn&#x27;t indicate when points are occur on top of each other.</p>
<p><a name="scatter-plot-3d-note"></a></p>
<h2 id="toc161"><span><a href="#scatter-plot-3d">3d scatter plot</a></span></h2>
<p><a name="bubble-chart-note"></a></p>
<h2 id="toc162"><span><a href="#bubble-chart">bubble chart</a></span></h2>
<p><a name="scatter-plot-matrix-note"></a></p>
<h2 id="toc163"><span><a href="#scatter-plot-matrix">scatter plot matrix</a></span></h2>
<p><a name="linear-regression-line-note"></a></p>
<h2 id="toc164"><span><a href="#linear-regression-line">linear regression line</a></span></h2>
<p>How to plot a line determined by linear regression on top of a scatter plot.</p>
<p><a name="q-q-plot-note"></a></p>
<h2 id="toc165"><span><a href="#q-q-plot">quantile-quantile plot</a></span></h2>
<p>Also called a Q-Q plot.</p>
<p>A quantile-quantile plot is a scatter plot created from two data sets. Each point depicts the quantile of the first data set with its x position and the corresponding quantile of the second data set with its y position.</p>
<p>If the data sets are drawn from the same distribution then most of the points should be close to the line y = x. If the data sets are drawn from distributions which have a linear relation then the Q-Q plot should also be close to linear.</p>
<p>If the two data sets have the same number of elements, one can simply sort them and create the scatterplot.</p>
<p>If the number of elements is different, one generates a set of quantiles (such as percentiles) for each set. The <tt>quantile</tt> function of MATLAB and R is convenient for this. With Python, one can use <tt>scipy.stats.scoreatpercentile</tt>.</p>
<p><a name="line-charts-note"></a></p>
<h1 id="toc166"><span><a href="#line-charts">Line Charts</a></span></h1>
<p><a name="polygonal-plot-note"></a></p>
<h2 id="toc167"><span><a href="#polygonal-plot">polygonal line plot</a></span></h2>
<p>How to connect the dots of a data set with a polygonal line.</p>
<p><a name="additional-line-note"></a></p>
<h2 id="toc168"><span><a href="#additional-line">additional line</a></span></h2>
<p>How to add another line to a plot.</p>
<p><a name="line-types-note"></a></p>
<h2 id="toc169"><span><a href="#line-types">line types</a></span></h2>
<p><a name="function-plot-note"></a></p>
<h2 id="toc170"><span><a href="#function-plot">function plot</a></span></h2>
<p>How to plot a function.</p>
<p><a name="area-chart-note"></a></p>
<h2 id="toc171"><span><a href="#area-chart">stacked area chart</a></span></h2>
<p><a name="overlapping-area-chart-note"></a></p>
<h2 id="toc172"><span><a href="#overlapping-area-chart">overlapping area chart</a></span></h2>
<p><a name="surface-charts-note"></a></p>
<h1 id="toc173"><span><a href="#surface-charts">Surface Charts</a></span></h1>
<p><a name="contour-plot-note"></a></p>
<h2 id="toc174"><span><a href="#contour-plot">contour plot</a></span></h2>
<p><a name="chart-options-note"></a></p>
<h1 id="toc175"><span><a href="#chart-options">Chart Options</a></span></h1>
<p><a name="chart-title-note"></a></p>
<h2 id="toc176"><span><a href="#chart-title">chart title</a></span></h2>
<p>How to set the chart title.</p>
<p><strong>r:</strong></p>
<p>The <tt>qplot</tt> commands supports the <tt>main</tt> options for setting the title:</p>
<div class="code">
<pre>
<code>qplot(x=&quot;rnorm&quot;, y=rnorm(50), geom=&quot;boxplot&quot;, main=&quot;boxplot example&quot;)</code>
</pre></div>
<p><a name="axis-labels-note"></a></p>
<h2 id="toc177"><span><a href="#axis-labels">axis labels</a></span></h2>
<p>How to label the x and y axes.</p>
<p><strong>r:</strong></p>
<p>How to label the axes with ggplot2:</p>
<div class="code">
<pre>
<code>x = rnorm(20)
y = x^2

p = ggplot(data.frame(x, y), aes(x, y))
p + layer(geom=&quot;point&quot;) + xlab(&#x27;x&#x27;) + ylab(&#x27;x squared&#x27;)</code>
</pre></div>
<p><a name="axis-limits-note"></a></p>
<h2 id="toc178"><span><a href="#axis-limits">axis limits</a></span></h2>
<p>How to manually set the range of values displayed by an axis.</p>
<p><a name="logarithmic-y-axis-note"></a></p>
<h2 id="toc179"><span><a href="#logarithmic-y-axis">logarithmic y-axis</a></span></h2>
<p><a name="colors-note"></a></p>
<h2 id="toc180"><span><a href="#colors">colors</a></span></h2>
<p>How to set the color of points and lines.</p>
<p><a name="superimposed-plots-note"></a></p>
<h2 id="toc181"><span><a href="#superimposed-plots">superimposed plots with different y-axis scales</a></span></h2>
<p>How to superimpose two plots with different y-axis scales.</p>
<p>To minimize the risk that the reader will read off an incorrect y-value for a data point, the example uses the same color for the y-axis as it does for the corresponding data set.</p>
<p><a name="legend-note"></a></p>
<h2 id="toc182"><span><a href="#legend">legend</a></span></h2>
<p>How to put a legend on a chart.</p>
<p><strong>r:</strong></p>
<p>These strings can be used as the first argument to control the legend position:</p>
<ul>
<li>&quot;bottomright&quot;</li>
<li>&quot;bottom&quot;</li>
<li>&quot;bottomleft&quot;</li>
<li>&quot;left&quot;</li>
<li>&quot;topleft&quot;</li>
<li>&quot;top&quot;</li>
<li>&quot;topright&quot;</li>
<li>&quot;right&quot;</li>
<li>&quot;center&quot;</li>
</ul>
<p>The named parameter <tt>lwd</tt> is the line width. It is roughly the width in pixels, though the exact interpretation is device specific.</p>
<p>The named parameter <tt>lty</tt> specifies the line type. The value can be either an integer or a string:</p>
<table class="wiki-content-table">
<tr>
<th>number</th>
<th>string</th>
</tr>
<tr>
<td>0</td>
<td>&#x27;blank&#x27;</td>
</tr>
<tr>
<td>1</td>
<td>&#x27;solid&#x27;</td>
</tr>
<tr>
<td>2</td>
<td>&#x27;dashed&#x27;</td>
</tr>
<tr>
<td>3</td>
<td>&#x27;dotted&#x27;</td>
</tr>
<tr>
<td>4</td>
<td>&#x27;dotdash&#x27;</td>
</tr>
<tr>
<td>5</td>
<td>&#x27;longdash&#x27;</td>
</tr>
<tr>
<td>6</td>
<td>&#x27;twodash&#x27;</td>
</tr>
</table>
<p><a name="matlab"></a></p>
<h1 id="toc183"><span><a href="#top">MATLAB</a></span></h1>
<p><a href="http://www.gnu.org/software/octave/doc/interpreter/">Octave Manual</a><br />
<a href="http://www.mathworks.com/help/techdoc/">MATLAB Documentation</a><br />
<a href="http://en.wikibooks.org/wiki/MATLAB_Programming/Differences_between_Octave_and_MATLAB">Differences between Octave and MATLAB</a><br />
<a href="http://octave.sourceforge.net/packages.php">Octave-Forge Packages</a></p>
<p>The basic data type of MATLAB is a matrix of floats. There is no distinction between a scalar and a 1x1 matrix, and functions that work on scalars typically work on matrices as well by performing the scalar function on each entry in the matrix and returning the results in a matrix with the same dimensions. Operators such as the logical operators (&#x27;&amp;&#x27; &#x27;|&#x27; &#x27;!&#x27;), relational operators (&#x27;==&#x27;, &#x27;!=&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;), and arithmetic operators (&#x27;+&#x27;, &#x27;-&#x27;) all work this way. However the multiplication &#x27;*&#x27; and division &#x27;/&#x27; operators perform matrix multiplication and matrix division, respectively. The <tt>.*</tt> and <tt>./</tt> operators are available if entry-wise multiplication or division is desired.</p>
<p>Floats are by default double precision; single precision can be specified with the <em>single</em> constructor. MATLAB has convenient matrix literal notation: commas or spaces can be used to separate row entries, and semicolons or newlines can be used to separate rows.</p>
<p>Arrays and vectors are implemented as single-row (<tt>1xn</tt>) matrices. As a result an <em>n</em>-element vector must be transposed before it can be multiplied on the right of a <tt>mxn</tt> matrix.</p>
<p>Numeric literals that lack a decimal point such as <em>17</em> and <em>-34</em> create floats, in contrast to most other programming languages. To create an integer, an integer constructor which specifies the size such as <em>int8</em> and <em>uint16</em> must be used. Matrices of integers are supported, but the entries in a given matrix must all have the same numeric type.</p>
<p>Strings are implemented as single-row (<tt>1xn</tt>) matrices of characters. Matrices cannot contain strings. If a string is put in matrix literal, each character in the string becomes an entry in the resulting matrix. This is consistent with how matrices are treated if they are nested inside another matrix. The following literals all yield the same string or <tt>1xn</tt> matrix of characters:</p>
<div class="code">
<pre>
<code>&#x27;foo&#x27;
[ &#x27;f&#x27; &#x27;o&#x27; &#x27;o&#x27; ]
[ &#x27;foo&#x27; ]
[ [ &#x27;f&#x27; &#x27;o&#x27; &#x27;o&#x27; ] ]</code>
</pre></div>
<p><em>true</em> and <em>false</em> are functions which return matrices of ones and zeros. The ones and zeros have type <em>logical</em> instead of <em>double</em>, which is created by the literals 1 and 0. Other than having a different class, the 0 and 1 of type <em>logical</em> behave the same as the 0 and 1 of type <em>double</em>.</p>
<p>MATLAB has a tuple type (in MATLAB terminology, a cell array) which can be used to hold multiple strings. It can also hold values with different types.</p>
<p><a name="r"></a></p>
<h1 id="toc184"><span><a href="#top">R</a></span></h1>
<p><a href="http://cran.r-project.org/doc/manuals/R-intro.html">An Introduction to R</a><br />
<a href="http://adv-r.had.co.nz/">Advanced R Programming</a><br />
<a href="http://cran.r-project.org/">The Comprehensive R Archive Network</a></p>
<p>The primitive data types of R are vectors of floats, vectors of strings, and vectors of booleans. There is no distinction between a scalar and a vector with one entry in it. Functions and operators which accept a scalar argument will typically accept a vector argument, returning a vector of the same size with the scalar operation performed on each the entries of the original vector.</p>
<p>The scalars in a vector must all be of the same type, but R also provides a <em>list</em> data type which can be used as a tuple (entries accessed by index), record (entries accessed by name), or even as a dictionary.</p>
<p>In addition R provides a <em>data frame</em> type which is a list (in R terminology) of vectors all of the same length. Data frames are equivalent to the data sets of other statistical analysis packages.</p>
<p><a name="numpy"></a></p>
<h1 id="toc185"><span><a href="#top">NumPy</a></span></h1>
<p><a href="http://docs.scipy.org/doc/">NumPy and SciPy Documentation</a><br />
<a href="http://matplotlib.sourceforge.net/">matplotlib intro</a><br />
<a href="http://www.scipy.org/NumPy_for_Matlab_Users">NumPy for Matlab Users</a><br />
<a href="http://pandas.pydata.org/pandas-docs/stable/">Pandas Documentation</a><br />
<a href="http://pandas.pydata.org/pandas-docs/dev/genindex.html">Pandas Method/Attribute Index</a></p>
<p>NumPy is a Python library which provides a data type called <tt>array</tt>. It differs from the Python <tt>list</tt> data type in the following ways:</p>
<ul>
<li>N-dimensional. Although the <tt>list</tt> type can be nested to hold higher dimension data, the <tt>array</tt> can hold higher dimension data in a space efficient manner without using indirection.</li>
<li>homogeneous. The elements of an <tt>array</tt> are restricted to be of a specified type. The NumPy library introduces new primitive types not available in vanilla Python. However, the element type of an array can be <tt>object</tt> which permits storing anything in the array.</li>
</ul>
<p>In the reference sheet the <a href="#array">array section</a> covers the vanilla Python <tt>list</tt> and the <a href="#multidimensional-array">multidimensional array section</a> covers the NumPy <tt>array</tt>.</p>
<p><em>List the NumPy primitive types</em></p>
<p>SciPy, Matplotlib, and Pandas are libraries which depend on Numpy.</p>
<p><a name="julia"></a></p>
<h1 id="toc186"><span><a href="#top">Julia</a></span></h1>
<p><a href="http://julialang.org/">http://julialang.org/</a></p>
 
          </div>
        </div>
      </div>
      <div id="license-area" class="license-area">
        <a href="https://github.com/clarkgrubb/hyperpolyglot/issues">issue tracker</a> |
        content of this page licensed under
        <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">
        creative commons attribution-sharealike 3.0</a>
        <br>
      </div>
    </div>
  </div>
</div>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17129977-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>
</html>
